{
    "Tuần 1": {
        "Bai1": {
            "Code": "// Phung Manh Hoang 20215385\n// Problem: Sum Array\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n    int n_85;\n    int a_85[100000];\n    int sum_85 = 0;\n    cin >> n_85; // Nhap n\n\n    for (int i = 0; i < n_85; i++)\n    {\n        cin >> a_85[i];\n        sum_85 += a_85[i]; // Tinh tong tung phan tu cua mang\n    }\n    cout << sum_85; // In tong phan tu cua mang\n}",
            "Problem": "Problem: Week 1 - Sum Array\n\nDescription\nGiven a sequence of integers a1, a2, ..., an. Compute the sum Q of elements of this sequence.\n\nInput\nLine 1: contains n (1 <= n <= 1000000)\nLine 2: contains a1, a2, ..., an (-10000 <= ai <= 10000)\n\nOutput\nWrite the value of Q\n\nExample\n\nInput\n4\n3 2 5 4\n\nOutput\n14"
        },
        "Bai2": {
            "Problem": "Problem: Week 1 - List sequence of integer having 3 digits divisible by n\n\nDescription\nGiven a positive integer n, find all integer having 3 digits which is divisible by n.\n\nInput\nLine 1: contains a positive integer n (1 <= n <= 999)\n\nOutput\nWrite the sequence of numbers found (elements are separated by a SPACE character)\n\nExample\nInput \n200\n\nOutput \n200 400 600 800",
            "Code": "// Phung Manh Hoang 20215385\n// Problem: List sequence of integer having 3 digits divisible by n\n\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n    int n_85;\n    cin >> n_85; // Nhap n\n\n    //  Tim so nguyen co 3 chu so chia het cho n\n    for (int i = 1; i < 1000; i++)\n    {\n        int x_85 = n_85 * i;\n        if (x_85 > 999)\n            break;\n        if (x_85 >= 100 && x_85 <= 999)\n        {\n            cout << x_85 << \" \"; // In so nguyen co 3 chu so chia het cho n\n        }\n    }\n}\n"
        },
        "Bai3": {
            "Problem": "Problem: Week 1 - So s\u00e1nh ch\u00eanh l\u1ec7ch gi\u00e1 \u0111i\u1ec7n theo \u0111\u1ec1 xu\u1ea5t m\u1edbi c\u1ee7a EVN\n\nDescription\nHi\u1ec7n t\u1ea1i gi\u00e1 \u0111i\u1ec7n \u0111ang \u0111\u01b0\u1ee3c t\u00ednh theo b\u1eadc thang g\u1ed3m 6 m\u1ee9c (m\u1ee9c \u0111i\u1ec1u ch\u1ec9nh t\u1eeb 04/05/2023), v\u1edbi gi\u00e1 th\u1ea5p nh\u1ea5t (b\u1eadc 1) l\u00e0 1.728VND v\u00e0 gi\u00e1 b\u1eadc cao nh\u1ea5t l\u00e0 3.015 VND. Tuy nhi\u00ean EVN \u0111ang \u0111\u1ec1 xu\u1ea5t m\u1ed9t c\u00e1ch t\u00ednh gi\u00e1 \u0111i\u1ec7n b\u1eadc thang m\u1edbi ch\u1ec9 g\u1ed3m 5 m\u1ee9c nh\u01b0 hinh d\u01b0\u1edbi, gi\u00e1 th\u1ea5p nh\u1ea5t (b\u1eadc 1) kho\u1ea3ng 1.728 \u0111\u1ed3ng m\u1ed9t kWh v\u00e0 cao nh\u1ea5t (b\u1eadc 5) l\u00e0 3.457 \u0111\u1ed3ng m\u1ed9t kWh. \n\nB\u1eadc\tBi\u1ec3u gi\u00e1 hi\u1ec7n h\u00e0nh\tPh\u01b0\u01a1ng \u00e1n 5 b\u1eadc\n  \tM\u1ee9c s\u1eed d\u1ee5ng\tGi\u00e1 (*)\tM\u1ee9c s\u1eed d\u1ee5ng\tGi\u00e1\n1\t0-50 kWh\t1.728\t0-100 kWh\t1.728\n2\t51-100 kWh\t1.786\t101-200 kWh\t2.074\n3\t101-200 kWh\t2.074\t201-400 kWh\t2.612\n4\t201-300 kWh\t2.612\t401-700 kWh\t3.111\n5\t301-400 kWh\t2.919\t701 kWh tr\u1edf l\u00ean\t3.457\n6  \t401 kWh tr\u1edf l\u00ean\t3.015\t\t\n(*) Gi\u00e1 ch\u01b0a bao g\u1ed3m thu\u1ebf VAT\n\nH\u00e3y x\u00e2y d\u1ef1ng ch\u01b0\u01a1ng tr\u00ecnh nh\u1eadp v\u00e0o s\u1ed1 kwh \u0111i\u1ec7n c\u1ee7a m\u1ed9t h\u1ed9 ti\u00eau th\u1ee5 v\u00e0 so s\u00e1nh xem theo b\u1ea3ng gi\u00e1 m\u1edbi \u0111ang l\u1ea5y \u00fd ki\u1ebfn th\u00ec ti\u1ec1n \u0111i\u1ec7n ti\u00eau th\u1ee5 c\u1ee7a h\u1ed9 \u0111\u00f3 s\u1ebd t\u0103ng th\u00eam hay gi\u1ea3m \u0111i bao nhi\u00eau.\n\nINPUT: l\u00e0 s\u1ed1 kwh \u0111i\u1ec7n ti\u00eau th\u1ee5 c\u1ee7a h\u1ed9 (l\u00e0 s\u1ed1 nguy\u00ean)\nOUTPUT: l\u00e0 ch\u00eanh l\u1ec7ch gi\u1eefa gi\u00e1 theo \u0111\u1ec1 xu\u1ea5t v\u00e0 gi\u00e1 theo m\u00f4 h\u00ecnh b\u1eadc thang 6 m\u1ee9c \u0111ang \u0111\u01b0\u1ee3c \u00e1p d\u1ee5ng.\n\nVAT s\u1ebd \u0111\u01b0\u1ee3c l\u1ea5y l\u00e0 10%, v\u00e0 k\u1ebft qu\u1ea3 in ra s\u1ebd l\u1ea5y t\u1edbi 2 ch\u1eef s\u1ed1 th\u1eadp ph\u00e2n\n\nEXAMPLE \nINPUT\n540\nOUTPUT\n-22176.00\n\n\nINPUT\n70\nOUTPUT\n-1276.00",
            "Code": "// Phung Manh Hoang 20215385\n// Problem: So s\u00e1nh ch\u00eanh l\u1ec7ch gi\u00e1 \u0111i\u1ec7n theo \u0111\u1ec1 xu\u1ea5t m\u1edbi c\u1ee7a EVN\n\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n    int n_85;\n    cin >> n_85; // Nhap n\n    double oldPrice_85 = 0;\n    double newPrice_85 = 0;\n\n    // Tinh gia dien cu\n    if (n_85 >= 0 && n_85 <= 50)\n    {\n        oldPrice_85 = n_85 * 1.728 * 1100;\n    }\n    else if (n_85 <= 100)\n    {\n        oldPrice_85 = (86.4 + (n_85 - 50) * 1.786) * 1100;\n    }\n    else if (n_85 <= 200)\n    {\n        oldPrice_85 = (175.7 + (n_85 - 100) * 2.074) * 1100;\n    }\n    else if (n_85 <= 300)\n    {\n        oldPrice_85 = (383.1 + (n_85 - 200) * 2.612) * 1100;\n    }\n    else if (n_85 <= 400)\n    {\n        oldPrice_85 = (644.3 + (n_85 - 300) * 2.919) * 1100;\n    }\n    else\n    {\n        oldPrice_85 = (936.2 + (n_85 - 400) * 3.015) * 1100;\n    }\n\n    // Tinh gia dien moi\n    if (n_85 >= 0 && n_85 <= 100)\n    {\n        newPrice_85 = n_85 * 1.728 * 1100;\n    }\n    else if (n_85 <= 200)\n    {\n        newPrice_85 = (172.8 + (n_85 - 100) * 2.074) * 1100;\n    }\n    else if (n_85 <= 400)\n    {\n        newPrice_85 = (380.2 + (n_85 - 200) * 2.612) * 1100;\n    }\n    else if (n_85 <= 700)\n    {\n        newPrice_85 = (902.6 + (n_85 - 400) * 3.111) * 1100;\n    }\n    else\n    {\n        newPrice_85 = (1835.9 + (n_85 - 700) * 3.457) * 1100;\n    }\n\n    printf(\"%.2f\\n\", newPrice_85 - oldPrice_85); // In ket qua\n}\n"
        },
        "Bai4": {
            "Problem": "Problem: Week 1 - Convert a TEXT to Upper-Case\n\nDescription\nGiven a TEXT, write a program that converts the TEXT to upper-case. \n\nInput\nThe TEXT\n\nOutput\nThe TEXT in which characters are converted into upper-case\n\nExample \nInput \nHello John,\nHow are you?\n\nBye,\n\nOutput \nHELLO JOHN,\nHOW ARE YOU?\n\nBYE, ",
            "Code": "// Phung Manh Hoang 20215385\n// Problem: Convert a TEXT to Upper-Case\n\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n    string s_85;\n    while (getline(cin, s_85))\n    {\n        // Convert a TEXT to Upper-Case\n        for (int i = 0; s_85[i] != '\\0'; i++)\n        {\n            if (s_85[i] >= 'a' && s_85[i] <= 'z')\n            {\n                s_85[i] = s_85[i] - 32;\n            }\n        }\n        cout << s_85 << endl; // In ket qua\n    }\n}"
        },
        "Bai5": {
            "Problem": "Problem: Week 1 - Extract Year, Month, Date from a String YYYY-MM-DD\n\nDescription\nGiven a date which is a string under the format YYYY-MM-DD (in which YYYY is the year, MM is the month (the month \u00ed from 1 to 12), and DD is the date (the date is from 1 to 31)). Extract the year, month and date.\n\nInput\nLine 1: contains a string s  \nOutput\nif s is not under the format YYYY-MM-DD, then write INCORRECT. Otherwise, write year, month, and date separated by a SPACE character\n\nExample\nInput\n2023-10-04\nOutput\n2023 10 4\n\n\nInput\n2023-10-4\nOutput\nINCORRECT \n\nInput\n2023-10 04\nOutput\nINCORRECT\n",
            "Code": "// Phung Manh Hoang 20215385\n// Problem: Extract Year, Month, Date from a String YYYY-MM-DD\n\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n    string s_85;\n    getline(cin, s_85); // Nhap xau\n\n    // Kiem tra xau co dung dinh dang hay khong\n    if (s_85.size() != 10 || s_85[4] != '-' || s_85[7] != '-')\n    {\n        cout << \"INCORRECT\";\n        return 0;\n    }\n    int thang_85 = (s_85[5] - 48) * 10 + (s_85[6] - 48);\n    int ngay_85 = (s_85[8] - 48) * 10 + (s_85[9] - 48);\n\n    // Kiem tra xau co dung dinh dang hay khong\n    if (thang_85 < 1 || thang_85 > 12 || ngay_85 < 1 || ngay_85 > 31)\n    {\n        cout << \"INCORRECT\";\n        return 0;\n    }\n\n    // In ket qua\n    for (int i = 0; i < 10; i++)\n    {\n        if (s_85[i] == '-')\n            cout << ' ';\n        else if (i > 4 && s_85[i] == '0')\n            continue;\n        else\n            cout << s_85[i];\n    }\n}"
        },
        "Bai6": {
            "Problem": "Problem: Week 1 - List all numbers from 1 to n and its squares\n\nDescription\nGiven an integer n, print numbers from 1 to n and its squares.\n\nInput\nLine 1: contains a positive integer n (1 <= n <= 100)\nOutput\nEach line i (i = 1,...,n): contains i and i^2 (elements are separated by one SPACE character)\n\nExample\nInput\n3\nOutput\n1 1\n2 4\n3 9",
            "Code": "// Phung Manh Hoang 20215385\n// Problem: List all numbers from 1 to n and its squares\n\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n    int n_85;\n    cin >> n_85; // Nhap n\n    // Tinh binh phuong\n    for (int i = 1; i <= n_85; i++)\n    {\n        cout << i << \" \" << i * i << endl; // In ket qua\n    }\n}"
        },
        "Bai7": {
            "Problem": "Problem: Week 1 - Count odd and even number from a sequence\n\nDescription\nGiven a sequence of integer a1, a2, ..., an. Count the number of odd elements and even elements of the sequence.\n\nInput\nLine 1: contains a positive integer n (1 <= n <= 100000)\nLine 2: contains a1, a2, ..., an. (1 <= ai <= 1000000)\nOutput\nWrite the number of odd elements and the number of even elements (separated by a SPACE character)\n\nExample \nInput \n6\n2 3 4 3 7 1\nOutput \n4 2",
            "Code": "// Phung Manh Hoang 20215385\n// Problem: Count odd and even number from a sequence\n\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n    int n_85;\n    int arr_85[100000];\n    int odd_85 = 0;\n    int even_85 = 0;\n    cin >> n_85; // Nhap n\n\n    // Dem so chan va so le trong mang\n    for (int i = 0; i < n_85; i++)\n    {\n        cin >> arr_85[i];\n        if (arr_85[i] % 2 == 1)\n            odd_85++;\n        else\n            even_85++;\n    }\n    cout << odd_85 << \" \" << even_85; // In ket qua\n}"
        },
        "Bai8": {
            "Problem": "Problem: Week 1 - Add Subtract Multiplication Division of A and B\n\nDescription\nGiven 2 integers a and b. Compute a+b, a-b, a*b, a/b.\n\nInput\nLine 1 contains 2 integers a and b (1 <= a,b <= 1000)\nOutput\nWrite a+b, a-b, a*b, a/b  (4 integers are separated by a SPACE characters)\n\nExample\nInput\n9 4\n\nOutput \n13 5 36 2",
            "Code": "// Phung Manh Hoang 20215385\n// Problem: Add Subtract Multiplication Division of A and B\n\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n    int a_85, b_85;\n    cin >> a_85 >> b_85; // Nhap a va b\n\n    cout << a_85 + b_85 << \" \" << a_85 - b_85 << \" \" << a_85 * b_85 << \" \" << a_85 / b_85; // In ket qua\n}"
        },
        "Bai9": {
            "Problem": "Problem: Week 1 - Convert hh:mm:ss to seconds\n\nDescription\nGiven a time moment which is a string under the format hh:mm:ss (in which hh (0 <= hh <= 23) is the hour, mm (0 <= mm <= 59) is the minute, and ss (0 <= ss <= 59) is the second). Convert this time moment in seconds (result = hh*3600 + mm*60 + ss).\n\nInput\nLine 1: contains a string s representing the time moment.  \nOutput\nif s is not under the format hh:mm:ss, then write INCORRECT. Otherwise, write value converted.\n\nExample\nInput\n13:05:26\n\nOutput\n47126\n\n\nInput\n13:05:6\n\nOutput\nINCORRECT \n\nInput\n13:05 26\n\nOutput\nINCORRECT",
            "Code": "// Phung Manh Hoang 20215385\n// Problem: Convert hh:mm:ss to seconds\n\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n    string s;\n    getline(cin, s); // Nhap xau\n\n    // Kiem tra xem xau co dung dinh dang khong\n    if (s.size() != 8 || s[2] != ':' || s[5] != ':')\n    {\n        cout << \"INCORRECT\";\n        return 0;\n    }\n\n    int gio_85 = (s[0] - 48) * 10 + (s[1] - 48);\n    int phut_85 = (s[3] - 48) * 10 + (s[4] - 48);\n    int giay_85 = (s[6] - 48) * 10 + (s[7] - 48);\n\n    // Kiem tra xem xau co dung dinh dang khong\n    if (gio_85 < 0 || gio_85 > 23 || phut_85 < 0 || phut_85 > 59 || giay_85 < 0 || giay_85 > 59)\n    {\n        cout << \"INCORRECT\";\n        return 0;\n    }\n\n    cout << gio_85 * 3600 + phut_85 * 60 + giay_85; // In ket qua\n}"
        },
        "Bai10": {
            "Problem": "Problem: Week 1 - Solve degree-2 polynomial equation\n\nDescription\nGiven an equation ax^2 + bx + c = 0. Find solution to the given equation.\n\nInput\nLine 1 contains 3 integers a, b, c \nOutput\nWrite NO SOLUTION if the given equation has no solution \nWrite x0 (2 digits after the decimal point) if the given equation has one solution x0 \nWrite x1 and x2 with x1 < x2 (2 digits after the decimal point) if the given equation has two distinct solutions x1, x2 \n\nExample\nInput \n1 1 8\nOutput \nNO SOLUTION \n\n\nInput \n1 -2 1\nOutput\n1.00\n\nInput \n1 -7 10\nOutput \n2.00 5.00",
            "Code": "// Phung Manh Hoang 20215385\n// Problem: Solve degree-2 polynomial equation\n\n#include <iostream>\n#include <math.h>\n\nusing namespace std;\n\nint main()\n{\n    int a_85, b_85, c_85;\n    double x1_85, x2_85;\n\n    cin >> a_85 >> b_85 >> c_85;                     // Nhap a, b, c\n    double delta_85 = b_85 * b_85 - 4 * a_85 * c_85; // Tinh delta\n\n    // Giai phuong trinh bac 2\n    if (delta_85 < 0)\n    {\n        cout << \"NO SOLUTION \"; // In ket qua\n    }\n    else if (delta_85 == 0)\n    {\n        x1_85 = x2_85 = -b_85 / (2 * a_85);\n        printf(\"%.2f\", x1_85); // In ket qua\n    }\n    else\n    {\n        delta_85 = sqrt(delta_85);\n        x1_85 = (-b_85 + delta_85) / (2 * a_85);\n        x2_85 = (-b_85 - delta_85) / (2 * a_85);\n\n        if (x1_85 < x2_85)\n            printf(\"%.2f %.2f\", x1_85, x2_85); // In ket qua\n        else\n            printf(\"%.2f %.2f\", x2_85, x1_85); // In ket qua\n    }\n}"
        },
        "Bai11": {
            "Problem": "Problem: Week 1 - Basic queries on array\n\nDescription\nGiven a sequence of integers a1, a2, ..., an. Perform a sequence of queries over this sequence including:\nfind-max: return the maximum element of the given sequence\nfind-min: return the minimum element of the given sequence \nsum: return the sum of the elements of the given sequence \nfind-max-segment i j: return the maximum element of the subsequence from index i to index j (i <= j)\n\nInput\nThe first block contains the information about the given sequence with the following format:\nLine 1: contains a positive integer n (1 <= n <= 10000)\nLine 2: contains n integers a1, a2, ..., an (-1000 <= ai <= 1000)\nThe first block is terminated by a character *\nThe second block contains a sequence of queries defined above, each query is in a line. The second block is terminated a 3 characters ***\n\nOutput\nWrite the result of each query in a corresponding line\n \nExample\nInput\n5\n1 4 3 2 5\n*\nfind-max\nfind-min\nfind-max-segment 1 3\nfind-max-segment 2 5\nsum\n***\n\nOutput\n5\n1\n4\n5\n15",
            "Code": "// Phung Manh Hoang 20215385\n// Problem: Basic queries on array\n\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n    int n_85;\n    int arr_85[100000];\n    string s_85; // Nhap xau\n    int sum_85 = 0;\n    cin >> n_85; // Nhap n\n\n    // Nhap mang\n    for (int i = 0; i < n_85; i++)\n    {\n        cin >> arr_85[i];\n        sum_85 += arr_85[i];\n    }\n\n    while (s_85 != \"***\")\n    {\n        cin >> s_85;\n        if (s_85 == \"sum\")          // Tinh tong\n            cout << sum_85 << endl; // In ket qua\n        if (s_85 == \"find-max\")     // Tim max\n        {\n            int max_85 = arr_85[0];\n            for (int i = 1; i < n_85; i++)\n            {\n                max_85 = (max_85 < arr_85[i]) ? arr_85[i] : max_85;\n            }\n            cout << max_85 << endl; // In ket qua\n        }\n        if (s_85 == \"find-min\") // Tim min\n        {\n            int min_85 = arr_85[0];\n            for (int i = 1; i < n_85; i++)\n            {\n                min_85 = (min_85 > arr_85[i]) ? arr_85[i] : min_85;\n            }\n            cout << min_85 << endl; // In ket qua\n        }\n        if (s_85 == \"find-max-segment\") // Tim max tu x den y\n        {\n            int x_85, y_85;\n            cin >> x_85 >> y_85; // Nhap x, y\n            int max_85 = arr_85[x_85 - 1];\n            for (int i = x_85 - 1; i <= y_85 - 1; i++)\n            {\n                max_85 = (max_85 < arr_85[i]) ? arr_85[i] : max_85;\n            }\n            cout << max_85 << endl; // In ket qua\n        }\n    }\n}"
        },
        "Bai12": {
            "Problem": "Problem: Week 1 - k-Subsequence even\n\nDescription\nGiven a sequence of integers a1, a2, . . ., an. A k-subsequence is define to be a sequence of k consecutive elements: ai, ai+1, . . ., ai+k-1. The weight of a k-subsequence is the sum of its elements.\nGiven positive integers k and m. Compute the number Q of k-subsequences such that the weight is even.\n\nInput\nLine 1: contains 2 positive integers n, k (1 <= n <= 100000, 1 <= k <= n/2)\nLine 2: contains a1, a2, . . ., an. (1 <= ai <= 10000)\nOutput\nWrite the value Q\n\nExample\nInput\n6  3\n2 4 5 1 1 2 \n\nOutput\n2",
            "Code": "// Phung Manh Hoang 20215385\n// Problem: k-Subsequence even\n\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n    int n_85, k_85;\n    int arr_85[100000];\n    int count_85 = 0;\n    int sum_85 = 0;\n\n    cin >> n_85 >> k_85; // Nhap n, k\n\n    // Nhap cac phan tu cua mang\n    for (int i = 0; i < n_85; i++)\n    {\n        cin >> arr_85[i];\n    }\n\n    int x = k_85 - 1;\n\n    // Dem so day con co tong cac phan tu bang so chan\n    if (x < n_85)\n    {\n\n        for (int j = 0; j <= x; j++)\n        {\n            sum_85 += arr_85[j];\n        }\n        if (sum_85 % 2 == 0)\n            count_85++;\n    }\n\n    // Dem so day con co tong cac phan tu bang so chan\n    for (int i = 1; i < n_85; i++)\n    {\n        if (i + k_85 - 1 < n_85)\n        {\n            sum_85 += arr_85[i + k_85 - 1] - arr_85[i - 1];\n            if (sum_85 % 2 == 0)\n                count_85++;\n        }\n    }\n    cout << count_85; // In ket qua\n}"
        },
        "Bai13": {
            "Problem": "Problem: Week 1 - Count words\n\nDescription\nGiven a Text, write a prorgam to count the number Q of words (ignore characters SPACE, TAB, LineBreak) of this Text\n\nInput\nThe Text\n\nOutput\nWrite the number Q of words\n\nExample\nInput\nHanoi University Of Science and Technology\nSchool of Information and Communication Technology\n\n\nOutput\n12",
            "Code": "// Phung Manh Hoang 20215385\n// Problem: Count words\n\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n    string s_85;\n    int count_85 = 0;\n\n    // Nhap va tinh so tu\n    while (cin >> s_85)\n    {\n        count_85++;\n    }\n\n    cout << count_85 << endl; // In ket qua\n}"
        },
        "Bai14": {
            "Problem": "Problem: Week 1 - Text Replacement\n\nDescription\nCho v\u0103n b\u1ea3n T v\u00e0 2 m\u1eabu P1, P2 \u0111\u1ec1u l\u00e0 c\u00e1c x\u00e2u k\u00fd t\u1ef1 (kh\u00f4ng ch\u1ee9a k\u00fd t\u1ef1 xu\u1ed1ng d\u00f2ng, \u0111\u1ed9 d\u00e0i kh\u00f4ng v\u01b0\u1ee3t qu\u00e1 1000). H\u00e3y thay th\u1ebf c\u00e1c x\u00e2u P1 trong T b\u1eb1ng x\u00e2u P2.\n\nD\u1eef li\u1ec7u\n\u00b7 D\u00f2ng 1: x\u00e2u P1\n\u00b7 D\u00f2ng 2: x\u00e2u P2\n\u00b7 D\u00f2ng 3: v\u0103n b\u1ea3n T\nK\u1ebft qu\u1ea3:\n\u00b7 Ghi v\u0103n b\u1ea3n T sau khi thay th\u1ebf\n\nV\u00ed d\u1ee5\nD\u1eef li\u1ec7u\nAI\nArtificial Intelligence\nRecently, AI is a key technology. AI enable efficient operations in many fields.\n\nK\u1ebft qu\u1ea3\nRecently, Artificial Intelligence is a key technology. Artificial Intelligence enable efficient operations in many fields.\n",
            "Code": "// Phung Manh Hoang 20215385\n// Problem: Text Replacement\n\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n    string P1_85;\n    string P2_85;\n    string T_85;\n\n    getline(cin, P1_85); // Nhap sau P1\n    getline(cin, P2_85); // Nhap sau P2\n    getline(cin, T_85);  // Nhap sau T\n\n    // Doi cho hai xau P1 va P2 trong T\n    while (T_85.find(P1_85) != -1)\n        T_85.replace(T_85.find(P1_85), P1_85.size(), P2_85);\n    cout << T_85; // In ket qua\n}"
        }
    },
    "Tuần 2": {
        "Bai1": {
            "Problem": "Problem: Week 2 - D\u00e3y fibonacci\n\nDescription\nGiven a fibonacci sequence a[0], a[1], a[2], ... in which:  a[0] = 0, a[1] = 1, a[n] = a[n-1] + a[n-2], for all n >= 2\nGiven  positive integer n, compute a[n-1].\n\nInput\nLine 1: contains a positive integer n (2 <= n <= 21)\nOutput\nWrite a[n-1]\n\nExample\nInput\n9\nOutput\n21",
            "Code": "// Phung Manh Hoang 20215385\n//  Problem: D\u00e3y fibonacci\n\n#include <iostream>\n\nusing namespace std;\n\nint fibonasi(int n_85)\n{\n    int fib_85[n_85 + 1];\n    fib_85[0] = 0;\n    fib_85[1] = 1;\n    for (int i = 2; i <= n_85; i++)\n    {\n        fib_85[i] = fib_85[i - 1] + fib_85[i - 2];\n    }\n    return fib_85[n_85];\n}\n\nint main()\n{\n    int n_85;\n    cin >> n_85;\n    cout << fibonasi(n_85 - 1);\n}"
        },
        "Bai2": {
            "Problem": "Problem: Week 2 - Compute C_k_n\n\nDescription\nGiven two positive integers k and n. Compute C(k,n) which is the number of ways to select k objects from a given set of n objects.\n\nInput\nLine 1: two positive integers k and n (1 <= k,n <= 999)\nOutput\nWrite te value C(k,n) modulo 10\n9\n+7.\n\nExample\nInput\n3  5\nOutput\n10\n",
            "Code": "// Phung Manh Hoang 20215385\n//  Problem: Compute C_k_n\n#include <iostream>\nusing namespace std;\n#define ll long long\n#define mod (ll)(1e9 + 7)\n\n// Tinh x^y\nll power(ll x_85, ll y_85, ll p_85)\n{\n    ll res_85 = 1;\n    x_85 = x_85 % p_85;\n    while (y_85 > 0)\n    {\n        if (y_85 & 1)\n            res_85 = (res_85 * x_85) % p_85;\n        y_85 = y_85 >> 1;\n        x_85 = (x_85 * x_85) % p_85;\n    }\n    return res_85;\n}\n\n// Tinh n^(-1) mod p\nll modInverse(ll n_85, ll p_85)\n{\n    return power(n_85, p_85 - 2, p_85);\n}\n\n// Tinh n!\nll gt(int n_85)\n{\n    ll s_85 = 1;\n    for (int i = 1; i <= n_85; i++)\n    {\n        s_85 = (s_85 * i) % mod;\n    }\n    return s_85;\n}\n\n// Tinh C_k_n mod p\nll C_k_n(int k_85, int n_85, int p_85)\n{\n    return (gt(n_85) * modInverse(gt(k_85), p_85) % p_85 * modInverse(gt(n_85 - k_85), p_85) % p_85) % p_85;\n}\n\nint main()\n{\n    int k_85, n_85;\n    cin >> k_85 >> n_85;\n    cout << C_k_n(k_85, n_85, mod);\n}"
        },
        "Bai3": {
            "Problem": "Problem: Week 2 - Binary sequence generation\n\nDescription\nGiven an integer n, write a program that generates all the binary sequences of length n in a lexicographic order.\n\nInput\nLine 1: contains an integer n (1 <= n <= 20)\nOutput\nWrite binary sequences in a lexicographic ordder, eac sequence in a line\n\nExample\nInput\n3\nOutput\n000\n001\n010\n011\n100\n101\n110\n111",
            "Code": "// Phung Manh Hoang 20215385\n//  Problem: Binary sequence generation\n\n#include <iostream>\n\nusing namespace std;\n\nint x_85[100000];\n\n// In ket qua ra man hinh\nvoid print(int n_85)\n{\n    for (int i = 0; i < n_85; i++)\n    {\n        cout << x_85[i];\n    }\n    cout << endl;\n}\n\n// Ham sinh xau nhi phan\nvoid Solve(int k_85, int n_85)\n{\n    for (int i = 0; i <= 1; i++)\n    {\n        x_85[k_85 - 1] = i;\n        if (k_85 == n_85)\n        {\n            print(n_85);\n        }\n        else\n            Solve(k_85 + 1, n_85);\n    }\n}\n\nint main()\n{\n    int n_85;\n    cin >> n_85;\n    Solve(1, n_85);\n}"
        },
        "Bai4": {
            "Problem": "Problem: Week 2 - Binary sequences generation without consecutive 11\n\nDescription\nGiven an integer n, write a program that generates all binary sequences without consecutive 11 in a lexicographic order.\n\nInput\nLine 1: contains an integer n (1 <= n <= 20)\nOutput\nWrite binary sequences in a lexicographic order, each sequence in a line\n\nExample\nInput\n3\nOutput\n000\n001\n010\n100\n101",
            "Code": "// Phung Manh Hoang 20215385\n//  Problem: Binary sequences generation without consecutive 11\n\n#include <iostream>\n\nusing namespace std;\n\nint x_85[100000];\n\n// In ket qua ra man hinh\nvoid print(int n_85)\n{\n    for (int i = 0; i < n_85; i++)\n    {\n        cout << x_85[i];\n    }\n    cout << endl;\n}\n\n// Ham sinh xau nhi phan ma khong co hai so 1 lien tiep\nvoid Solve(int k_85, int n_85)\n{\n    for (int i = 0; i <= 1; i++)\n    {\n\n        if (x_85[k_85 - 2] + i < 2 || k_85 == 1)\n        {\n            x_85[k_85 - 1] = i;\n            if (k_85 == n_85)\n                print(n_85);\n            else\n                Solve(k_85 + 1, n_85);\n        }\n    }\n}\n\nint main()\n{\n    int n_85;\n    cin >> n_85;\n    Solve(1, n_85);\n}"
        },
        "Bai5": {
            "Problem": "Problem: Week 2 - Permutation generation\n\nDescription\nGiven an integer n, write a program to generate all permutations of 1, 2, ..., n in a lexicalgraphic order (elements of a permutation are separated by a SPACE character).\n\nExample\nInput \n3\nOutput\n1 2 3 \n1 3 2 \n2 1 3 \n2 3 1 \n3 1 2 \n3 2 1 ",
            "Code": "// Phung Manh Hoang 20215385\n//  Problem: Permutation generation\n\n#include <iostream>\n\nusing namespace std;\n\nint x_85[100000];\nint check_85[100000];\n\n// In ket qua ra man hinh\nvoid print(int n_85)\n{\n    for (int i = 1; i <= n_85; i++)\n    {\n        cout << x_85[i] << \" \";\n    }\n    cout << endl;\n}\n\n// Ham sinh hoan vi cua n\nvoid Solve(int k_85, int n_85)\n{\n    for (int i = 1; i <= n_85; i++)\n    {\n        if (!check_85[i])\n        {\n            x_85[k_85] = i;\n            check_85[i] = 1;\n            if (k_85 == n_85)\n                print(n_85);\n            else\n                Solve(k_85 + 1, n_85);\n            check_85[i] = 0;\n        }\n    }\n}\n\nint main()\n{\n    int n_85;\n    cin >> n_85;\n    Solve(1, n_85);\n}"
        },
        "Bai6": {
            "Problem": "Problem: Week 2 - Count number of sudoku solutions\n\nDescription\nWrite a program to compute the number of sudoku solutions (fill the zero elements of a given partial sudoku table)\nFill numbers from 1, 2, 3, .., 9 to 9 x 9 table so that:\nNumbers of each row are distinct\nNumbers of each column are distinct\nNumbers on each sub-square 3 x 3 are distinct\n\nInput\nEach line i (i = 1, 2, ..., 9) contains elements of the i\nth\n row of the Sudoku table: elements are numbers from 0 to 9 (value 0 means the empty cell of the table)\nOutput\nWrite the number of solutions found\n\nExample\nInput\n0 0 3 4 0 0 0 8 9\n0 0 6 7 8 9 0 2 3\n0 8 0 0 2 3 4 5 6\n0 0 4 0 6 5 0 9 7\n0 6 0 0 9 0 0 1 4\n0 0 7 2 0 4 3 6 5\n0 3 0 6 0 2 0 7 8\n0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0\nOutput\n64",
            "Code": "// Phung Manh Hoang 20215385\n//  Problem: Count number of sudoku solutions\n\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int N_85 = 9;\nint grid_85[N_85][N_85];\n\n// Kiem tra xem ket qua dung khong\nbool is_valid(int row_85, int col_85, int num_85)\n{\n    for (int i = 0; i < N_85; i++)\n    {\n        if (grid_85[row_85][i] == num_85 || grid_85[i][col_85] == num_85)\n        {\n            return false;\n        }\n    }\n    int sub_row_85 = row_85 - row_85 % 3;\n    int sub_col_85 = col_85 - col_85 % 3;\n    for (int i = sub_row_85; i < sub_row_85 + 3; i++)\n    {\n        for (int j = sub_col_85; j < sub_col_85 + 3; j++)\n        {\n            if (grid_85[i][j] == num_85)\n            {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\n// Dem so dap an sodoku\nint solve(int row_85, int col_85)\n{\n    if (row_85 == N_85)\n    {\n        return 1;\n    }\n    if (col_85 == N_85)\n    {\n        return solve(row_85 + 1, 0);\n    }\n    if (grid_85[row_85][col_85] != 0)\n    {\n        return solve(row_85, col_85 + 1);\n    }\n    int count_85 = 0;\n    for (int i = 1; i <= N_85; i++)\n    {\n        if (is_valid(row_85, col_85, i))\n        {\n            grid_85[row_85][col_85] = i;\n            count_85 += solve(row_85, col_85 + 1);\n            grid_85[row_85][col_85] = 0;\n        }\n    }\n    return count_85;\n}\n\nint main()\n{\n    for (int i = 0; i < N_85; i++)\n    {\n        for (int j = 0; j < N_85; j++)\n        {\n            cin >> grid_85[i][j];\n        }\n    }\n    cout << solve(0, 0) << endl;\n}"
        },
        "Bai7": {
            "Problem": "Problem: Linear Integer Equation - coefficent 1\n\nDescription\nGiven two integer n and M. Write a program that generates all ordered collection (X1, X2, ..., Xn) such that: X1 + X2 + . . . + Xn = M\n\nInput\nLine 1: contains 2 integers n and M (2 <= n <= 10, 1 <= M <= 20)\nOutput\nWrite in each line X1, X2, ..., Xn separated by a SPACE character\n\nExample\nInput\n3  5\nOutput\n1 1 3\n1 2 2\n1 3 1\n2 1 2\n2 2 1\n3 1 1",
            "Code": "// Phung Manh Hoang 20215385\n//  Problem: Linear Integer Equation - coefficent 1\n\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Ham sinh ra cac nghiem cua phuong trinh\nvoid Solve(int n_85, int M_85, vector<int> &prefix_85)\n{\n    if (n_85 == 0)\n    {\n        if (M_85 == 0)\n        {\n            for (int i = 0; i < prefix_85.size(); i++)\n            {\n                cout << prefix_85[i] << \" \";\n            }\n            cout << endl;\n        }\n        return;\n    }\n    for (int i = 1; i <= M_85; i++)\n    {\n        prefix_85.push_back(i);\n        Solve(n_85 - 1, M_85 - i, prefix_85);\n        prefix_85.pop_back();\n    }\n}\n\nint main()\n{\n    int n_85, M_85;\n    cin >> n_85 >> M_85;\n    vector<int> prefix_85;\n    Solve(n_85, M_85, prefix_85);\n    return 0;\n}\n"
        }
    },
    "Tuần 3": {
        "Bai1": {
            "Problem": "Problem: Week 3 - Simulation Stack\n\nDescription\nPerform a sequence of operations over a stack, each element is an integer:\nPUSH v: push a value v into the stack\nPOP: remove an element out of the stack and print this element to stdout (print NULL if the stack is empty)\n\nInput\nEach line contains a command (operration) of type \nPUSH  v\nPOP\nOutput\nWrite the results of POP operations (each result is written in a line)\n\nExample\nInput\nPUSH 1\nPUSH 2\nPUSH 3\nPOP\nPOP\nPUSH 4\nPUSH 5\nPOP\n#\nOutput\n3\n2\n5",
            "Code": "// Phung Manh Hoang 20215385\n// Problem: Simulation Stack\n\n#include <iostream>\n\nusing namespace std;\n\n// Tao cau truc Node\nstruct Node\n{\n    int data_85;\n    Node *next_85;\n};\n\n// Tao cau truc Stack\nstruct Stack\n{\n    int top_85;\n    Node *head_85;\n};\n\n// Khoi tao Stack\nStack initStack()\n{\n    Stack S_85;\n    S_85.top_85 = 0;\n    S_85.head_85 = NULL;\n    return S_85;\n}\n\n// Khoi tao Node\nNode *initNode(int data_85)\n{\n    Node *temp_85_85 = new Node();\n    temp_85_85->data_85 = data_85;\n    temp_85_85->next_85 = NULL;\n    return temp_85_85;\n}\n\n// Them Node vao Stack\nvoid Push(Stack &S_85, int data_85)\n{\n    Node *temp_85 = initNode(data_85);\n    temp_85->next_85 = S_85.head_85;\n    S_85.head_85 = temp_85;\n    S_85.top_85++;\n}\n\n// Xoa Node khoi Stack\nvoid Pop(Stack &S_85)\n{\n    if (S_85.top_85 > 0)\n    {\n        S_85.top_85--;\n        cout << S_85.head_85->data_85 << endl;\n        Node *temp_85 = S_85.head_85->next_85;\n        delete (S_85.head_85);\n        S_85.head_85 = temp_85;\n        return;\n    }\n    cout << \"NULL\" << endl;\n}\n\n// Xoa Stack\nvoid deleteStack(Stack &S_85)\n{\n    while (S_85.top_85 > 0)\n    {\n        Node *temp_85 = S_85.head_85->next_85;\n        delete (S_85.head_85);\n        S_85.head_85 = temp_85;\n        S_85.top_85--;\n    }\n}\n\nint main()\n{\n    Stack S_85 = initStack();\n    string str_85;\n    int x_85;\n\n    do\n    {\n        cin >> str_85;\n        // Them Node vao Stack\n        if (str_85 == \"PUSH\")\n        {\n            cin >> x_85;\n            Push(S_85, x_85);\n        }\n        // Xoa Node khoi Stack\n        else if (str_85 == \"POP\")\n            Pop(S_85);\n\n    } while (str_85 != \"#\");\n\n    deleteStack(S_85);\n}"
        },
        "Bai2": {
            "Problem": "Problem: Week 3 - Simulation Queue\n\nDescription\nPerform a sequence of operations over a queue, each element is an integer:\nPUSH v: push a value v into the queue\nPOP: remove an element out of the queue and print this element to stdout (print NULL if the queue is empty)\n\nInput\nEach line contains a command (operration) of type\nPUSH  v\nPOP\nOutput\nWrite the results of POP operations (each result is written in a line)\n\nExample\nInput\nPUSH 1\nPUSH 2\nPUSH 3\nPOP\nPOP\nPUSH 4\nPUSH 5\nPOP\n#\nOutput\n1\n2\n3\n\nInput\nPUSH 1\nPOP\nPOP\nPUSH 4\nPOP\n#\nOutput\n1\nNULL\n4",
            "Code": "// Phung Manh Hoang 20215385\n// Problem: Simulation Queue\n\n#include <iostream>\n\nusing namespace std;\n\n// Tao cau truc Node\nstruct Node\n{\n    int data_85;\n    Node *next_85;\n};\n\n// Tao cau truc Queue\nstruct Queue\n{\n    int top_85;\n    Node *head_85;\n};\n\n// Khoi tao Queue\nQueue initQueue()\n{\n    Queue S_85;\n    S_85.top_85 = 0;\n    S_85.head_85 = NULL;\n    return S_85;\n}\n\n// Khoi tao Node\nNode *initNode(int data_85)\n{\n    Node *temp_85 = new Node();\n    temp_85->data_85 = data_85;\n    temp_85->next_85 = NULL;\n    return temp_85;\n}\n\n// Them Node vao Queue\nvoid Push(Queue &S_85, int data_85)\n{\n    Node *temp_85 = initNode(data_85);\n    temp_85->next_85 = S_85.head_85;\n    S_85.head_85 = temp_85;\n    S_85.top_85++;\n}\n\n// Xoa Node khoi Queue\nvoid Pop(Queue &S_85)\n{\n\n    if (S_85.top_85 > 1)\n    {\n        S_85.top_85--;\n        Node *temp_85 = S_85.head_85;\n        while (S_85.head_85->next_85->next_85 != NULL)\n        {\n            S_85.head_85 = S_85.head_85->next_85;\n        }\n        cout << S_85.head_85->next_85->data_85 << endl;\n        delete (S_85.head_85->next_85);\n        S_85.head_85->next_85 = NULL;\n        S_85.head_85 = temp_85;\n        return;\n    }\n    else if (S_85.top_85 == 1)\n    {\n        S_85.top_85--;\n        cout << S_85.head_85->data_85 << endl;\n        delete (S_85.head_85);\n        S_85.head_85 = NULL;\n        return;\n    }\n    cout << \"NULL\" << endl;\n}\n\n// Xoa Queue\nvoid deleteQueue(Queue &S_85)\n{\n    while (S_85.top_85 > 0)\n    {\n        Node *temp_85 = S_85.head_85->next_85;\n        delete (S_85.head_85);\n        S_85.head_85 = temp_85;\n        S_85.top_85--;\n    }\n}\n\nint main()\n{\n    Queue S_85 = initQueue();\n    string str_85;\n    int x_85;\n\n    do\n    {\n        cin >> str_85;\n        // Them Node vao Queue\n        if (str_85 == \"PUSH\")\n        {\n            cin >> x_85;\n            Push(S_85, x_85);\n        }\n        // Xoa Node khoi Queue\n        else if (str_85 == \"POP\")\n            Pop(S_85);\n\n    } while (str_85 != \"#\");\n\n    deleteQueue(S_85);\n}"
        },
        "Bai3": {
            "Problem": "Problem: Week 3 - Check Parenthesis\n\nDescription\nGiven a string containing only characters (, ), [, ] {, }. Write a program that checks whether the string is correct in expression.\n\nExample\n ([]{()}()[]): correct\n ([]{()]()[]): incorrect\nInput\nOne line contains the string (the length of the string is less than or equal to $10^6$)One line contains the string (the length of the string is less than or equal to 10\n6\n)\nOutput\nWrite 1 if the sequence is correct, and write 0, otherwise\n\nExample\nInput\n(()[][]{}){}{}[][]({[]()})\nOutput\n1",
            "Code": "// Phung Manh Hoang 20215385\n// Problem: Check Parenthesis\n\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main()\n{\n    vector<char> vecStr_85;\n    string str_85;\n    cin >> str_85;\n\n    int size = str_85.size();\n    for (int i = 0; i < size; i++)\n    {\n        // Nhap vao mot chuoi ky tu (,{,[,],},)\n        if (str_85[i] == '(' || str_85[i] == '[' || str_85[i] == '{')\n        {\n            vecStr_85.push_back(str_85[i]);\n        }\n\n        // Kiem tra xem xau co dung khong\n        if (str_85[i] == ')' || str_85[i] == ']' || str_85[i] == '}')\n        {\n            if (vecStr_85.empty())\n            {\n                cout << \"0\";\n                return 0;\n            }\n\n            char c_85 = vecStr_85.back();\n\n            if (c_85 == '(' && str_85[i] == ')')\n            {\n                vecStr_85.pop_back();\n            }\n            else if (c_85 == '[' && str_85[i] == ']')\n            {\n                vecStr_85.pop_back();\n            }\n            else if (c_85 == '{' && str_85[i] == '}')\n            {\n                vecStr_85.pop_back();\n            }\n            else\n            {\n                cout << \"0\";\n                return 0;\n            }\n        }\n    }\n\n    if (vecStr_85.empty())\n    {\n        cout << \"1\";\n    }\n    else\n    {\n        cout << \"0\";\n    }\n}"
        },
        "Bai4": {
            "Problem": "Problem: Week 3 - WATER JUGS\n\nDescription\nThere are two jugs, a-litres jug and b-litres jug (a, b are positive integers). There is a pump with unlimited water. Given a positive integer c, how to get exactly c litres.\n\nInput\n   Line 1: contains positive integers a,   b,  c  (1 <= a, b, c <= 900)\nOutput\n  write the number of steps or write -1 (if no solution found)\n\nExample\nInput\n6  8  4\nOutput\n4",
            "Code": "// Phung Manh Hoang 20215385\n// Problem: WATER JUGS\n\n#include <iostream>\n#include <queue>\n#include <stack>\n#include <list>\n\nusing namespace std;\n\n// Tao cau truc State\nstruct State\n{\n    int x_85;\n    int y_85;\n    State *p_85;\n};\n\n// Khoi tao cac gia tri\nbool visited_85[10000][10000];\nqueue<State *> Q_85;\nlist<State *> L_85;\nState *target_85;\nint a_85, b_85, c_85;\n\n// Tao mang trang thai\nvoid initVisited()\n{\n    for (int x_85 = 0; x_85 < 10000; x_85++)\n        for (int y_85 = 0; y_85 < 10000; y_85++)\n            visited_85[x_85][y_85] = false;\n}\n\n// Kiem tra trang thai dich\nbool reachTarget(State *S_85)\n{\n    return S_85->x_85 == c_85 || S_85->y_85 == c_85 ||\n           S_85->x_85 + S_85->y_85 == c_85;\n}\n\n// Ham danh dau trang thai\nvoid markVisit(State *S_85)\n{\n    visited_85[S_85->x_85][S_85->y_85] = true;\n}\n\n// Giai phong bo nho\nvoid freeMemory()\n{\n    list<State *>::iterator it_85;\n    for (it_85 = L_85.begin(); it_85 != L_85.end(); it_85++)\n    {\n        delete *it_85;\n    }\n}\n\n// Do het nuoc tu coc 1 ra ngoai\nbool genMove1Out(State *S_85)\n{\n    if (visited_85[0][S_85->y_85])\n        return false;\n    State *newS_85 = new State;\n    newS_85->x_85 = 0;\n    newS_85->y_85 = S_85->y_85;\n    newS_85->p_85 = S_85;\n    Q_85.push(newS_85);\n    markVisit(newS_85);\n    L_85.push_back(newS_85);\n    if (reachTarget(newS_85))\n    {\n        target_85 = newS_85;\n        return true;\n    }\n    return false;\n}\n\n// Do het nuoc tu coc 2 ra ngoai\nbool genMove2Out(State *S_85)\n{\n    if (visited_85[S_85->x_85][0])\n        return false;\n    State *newS_85 = new State;\n    newS_85->x_85 = S_85->x_85;\n    newS_85->y_85 = 0;\n    newS_85->p_85 = S_85;\n    Q_85.push(newS_85);\n    markVisit(newS_85);\n    L_85.push_back(newS_85);\n    if (reachTarget(newS_85))\n    {\n        target_85 = newS_85;\n        return true;\n    }\n    return false;\n}\n\n// Do nuoc tu coc 1 vao day coc 2\nbool genMove1Full2(State *S_85)\n{\n    if (S_85->x_85 + S_85->y_85 < b_85)\n        return false;\n    if (visited_85[S_85->x_85 + S_85->y_85 - b_85][b_85])\n        return false;\n    State *newS_85 = new State;\n    newS_85->x_85 = S_85->x_85 + S_85->y_85 - b_85;\n    newS_85->y_85 = b_85;\n    newS_85->p_85 = S_85;\n    Q_85.push(newS_85);\n    markVisit(newS_85);\n    L_85.push_back(newS_85);\n    if (reachTarget(newS_85))\n    {\n        target_85 = newS_85;\n        return true;\n    }\n    return false;\n}\n\n// Do nuoc tu coc 2 vao day coc 1\nbool genMove2Full1(State *S_85)\n{\n    if (S_85->x_85 + S_85->y_85 < a_85)\n        return false;\n    if (visited_85[a_85][S_85->x_85 + S_85->y_85 - a_85])\n        return false;\n    State *newS_85 = new State;\n    newS_85->x_85 = a_85;\n    newS_85->y_85 = S_85->x_85 + S_85->y_85 - a_85;\n\n    newS_85->p_85 = S_85;\n    Q_85.push(newS_85);\n    markVisit(newS_85);\n    L_85.push_back(newS_85);\n    if (reachTarget(newS_85))\n    {\n        target_85 = newS_85;\n        return true;\n    }\n    return false;\n}\n\n// Do het nuoc tu coc 1 vao coc 2\nbool genMoveAll12(State *S_85)\n{\n    if (S_85->x_85 + S_85->y_85 > b_85)\n        return false;\n    if (visited_85[0][S_85->x_85 + S_85->y_85])\n        return false;\n    State *newS_85 = new State;\n    newS_85->x_85 = 0;\n    newS_85->y_85 = S_85->x_85 + S_85->y_85;\n\n    newS_85->p_85 = S_85;\n    Q_85.push(newS_85);\n    markVisit(newS_85);\n    L_85.push_back(newS_85);\n    if (reachTarget(newS_85))\n    {\n        target_85 = newS_85;\n        return true;\n    }\n    return false;\n}\n\n// Do het nuoc tu coc 2 vao coc 1\nbool genMoveAll21(State *S_85)\n{\n    if (S_85->x_85 + S_85->y_85 > a_85)\n        return false;\n    if (visited_85[S_85->x_85 + S_85->y_85][0])\n        return false;\n    State *newS_85 = new State;\n    newS_85->x_85 = S_85->x_85 + S_85->y_85;\n    newS_85->y_85 = 0;\n\n    newS_85->p_85 = S_85;\n    Q_85.push(newS_85);\n    markVisit(newS_85);\n    L_85.push_back(newS_85);\n    if (reachTarget(newS_85))\n    {\n        target_85 = newS_85;\n        return true;\n    }\n    return false;\n}\n\n// Do day nuoc tu be vao coc 1\nbool genMoveFill1(State *S_85)\n{\n    if (visited_85[a_85][S_85->y_85])\n        return false;\n    State *newS_85 = new State;\n    newS_85->x_85 = a_85;\n    newS_85->y_85 = S_85->y_85;\n\n    newS_85->p_85 = S_85;\n    Q_85.push(newS_85);\n    markVisit(newS_85);\n    L_85.push_back(newS_85);\n    if (reachTarget(newS_85))\n    {\n        target_85 = newS_85;\n        return true;\n    }\n    return false;\n}\n\n// Do day nuoc tu be vao coc 2\nbool genMoveFill2(State *S_85)\n{\n    if (visited_85[S_85->x_85][b_85])\n        return false;\n    State *newS_85 = new State;\n    newS_85->x_85 = S_85->x_85;\n    newS_85->y_85 = b_85;\n\n    newS_85->p_85 = S_85;\n    Q_85.push(newS_85);\n    markVisit(newS_85);\n    L_85.push_back(newS_85);\n    if (reachTarget(newS_85))\n    {\n        target_85 = newS_85;\n        return true;\n    }\n    return false;\n}\n\n// In ra ket qua\nvoid print(State *target_85)\n{\n    if (target_85 == NULL)\n    {\n        cout << -1;\n        return;\n    }\n\n    State *currentS_85 = target_85;\n    stack<State *> actions_85;\n    while (currentS_85 != NULL)\n    {\n        actions_85.push(currentS_85);\n        currentS_85 = currentS_85->p_85;\n    }\n    cout << actions_85.size() - 1;\n}\n\n// Giai bai toan\nvoid solve()\n{\n    initVisited();\n    // sinh ra trang thai ban dau (0,0) va dua vao Q_85\n    State *S_85 = new State;\n    S_85->x_85 = 0;\n    S_85->y_85 = 0;\n    S_85->p_85 = NULL;\n    Q_85.push(S_85);\n    markVisit(S_85);\n    while (!Q_85.empty())\n    {\n        State *S_85 = Q_85.front();\n        Q_85.pop();\n        if (genMove1Out(S_85))\n            break;\n        if (genMove2Out(S_85))\n            break;\n        if (genMove1Full2(S_85))\n            break;\n        if (genMoveAll12(S_85))\n            break;\n        if (genMove2Full1(S_85))\n            break;\n        if (genMoveAll21(S_85))\n            break;\n        if (genMoveFill1(S_85))\n            break;\n        if (genMoveFill2(S_85))\n            break;\n    }\n}\n\nint main()\n{\n    cin >> a_85 >> b_85 >> c_85;\n    target_85 = NULL;\n    solve();\n    print(target_85);\n    freeMemory();\n}"
        },
        "Bai5": {
            "Problem": "Problem: Week 3 - Tree manipulation & Traversal\n\nDescription\nM\u1ed7i n\u00fat tr\u00ean c\u00e2y c\u00f3 tr\u01b0\u1eddng id (identifier) l\u00e0 m\u1ed9t s\u1ed1 nguy\u00ean (id c\u1ee7a c\u00e1c n\u00fat tr\u00ean c\u00e2y \u0111\u00f4i m\u1ed9t kh\u00e1c nhau)\nTh\u1ef1c hi\u1ec7n 1 chu\u1ed7i c\u00e1c h\u00e0nh \u0111\u1ed9ng sau \u0111\u00e2y bao g\u1ed3m c\u00e1c thao t\u00e1c li\u00ean quan \u0111\u1ebfn x\u00e2y d\u1ef1ng c\u00e2y v\u00e0 duy\u1ec7t c\u00e2y\n\u00b7 MakeRoot u: T\u1ea1o ra n\u00fat g\u1ed1c u c\u1ee7a c\u00e2y\n\u00b7 Insert u v: t\u1ea1o m\u1edbi 1 n\u00fat u v\u00e0 ch\u00e8n v\u00e0o cu\u1ed1i danh s\u00e1ch n\u00fat con c\u1ee7a n\u00fat v (n\u1ebfu n\u00fat c\u00f3 id b\u1eb1ng v kh\u00f4ng t\u1ed3n t\u1ea1i ho\u1eb7c n\u00fat c\u00f3 id b\u1eb1ng u \u0111\u00e3 t\u1ed3n t\u1ea1i th\u00ec kh\u00f4ng ch\u00e8n th\u00eam m\u1edbi)\n\u00b7 PreOrder: in ra th\u1ee9 t\u1ef1 c\u00e1c n\u00fat trong ph\u00e9p duy\u1ec7t c\u00e2y theo th\u1ee9 t\u1ef1 tr\u01b0\u1edbc\n\u00b7 InOrder: in ra th\u1ee9 t\u1ef1 c\u00e1c n\u00fat trong ph\u00e9p duy\u1ec7t c\u00e2y theo th\u1ee9 t\u1ef1 gi\u1eefa\n\u00b7 PostOrder: in ra th\u1ee9 t\u1ef1 c\u00e1c n\u00fat trong ph\u00e9p duy\u1ec7t c\u00e2y theo th\u1ee9 t\u1ef1 sau\nD\u1eef li\u1ec7u: bao g\u1ed3m c\u00e1c d\u00f2ng, m\u1ed7i d\u00f2ng l\u00e0 1 trong s\u1ed1 c\u00e1c h\u00e0nh \u0111\u1ed9ng \u0111\u01b0\u1ee3c m\u00f4 t\u1ea3 \u1edf tr\u00ean, d\u00f2ng cu\u1ed1i d\u00f9ng l\u00e0 * (\u0111\u00e1nh d\u1ea5u s\u1ef1 k\u1ebft th\u00fac c\u1ee7a d\u1eef li\u1ec7u).\nK\u1ebft qu\u1ea3: ghi ra tr\u00ean m\u1ed7i d\u00f2ng, th\u1ee9 t\u1ef1 c\u00e1c n\u00fat \u0111\u01b0\u1ee3c th\u0103m trong ph\u00e9p duy\u1ec7t theo th\u1ee9 t\u1ef1 tr\u01b0\u1edbc, gi\u1eefa, sau c\u1ee7a c\u00e1c h\u00e0nh \u0111\u1ed9ng PreOrder, InOrder, PostOrder t\u01b0\u01a1ng \u1ee9ng \u0111\u1ecdc \u0111\u01b0\u1ee3c t\u1eeb d\u1eef li\u1ec7u \u0111\u1ea7u v\u00e0o\n\nV\u00ed d\u1ee5\nD\u1eef li\u1ec7u\nMakeRoot 10\nInsert 11 10\nInsert 1 10\nInsert 3 10\nInOrder\nInsert 5 11\nInsert 4 11\nInsert 8 3\nPreOrder\nInsert 2 3\nInsert 7 3\nInsert 6 4\nInsert 9 4\nInOrder\nPostOrder\n*\nK\u1ebft qu\u1ea3\n11 10 1 3\n10 11 5 4 1 3 8\n5 11 6 4 9 10 1 8 3 2 7\n5 6 9 4 11 1 8 2 7 3 10",
            "Code": "// Phung Manh Hoang 20215385\n// Problem: Tree manipulation & Traversal\n\n#include <iostream>\n\nusing namespace std;\n\n// Tao cau truc Node\ntypedef struct Node\n{\n    int data_85;\n    Node *leftMostChild_85;\n    Node *rightSibling_85;\n} Node;\n\n// Khoi tao Node\nNode *initNode()\n{\n    Node *root_85 = NULL;\n    return root_85;\n}\n\n// Tao Node moi\nNode *newNode(Node *root_85, int x_85)\n{\n    Node *node_85 = new Node;\n    node_85->data_85 = x_85;\n    node_85->leftMostChild_85 = NULL;\n    node_85->rightSibling_85 = NULL;\n    return node_85;\n}\n\n// Tim Node co gia tri x\nNode *findNode(Node *root_85, int x_85)\n{\n    if (root_85 == NULL)\n        return NULL;\n    if (root_85->data_85 == x_85)\n        return root_85;\n    Node *p_85 = root_85->leftMostChild_85;\n    while (p_85 != NULL)\n    {\n        Node *q_85 = findNode(p_85, x_85);\n        if (q_85 != NULL)\n            return q_85;\n        p_85 = p_85->rightSibling_85;\n    }\n    return NULL;\n}\n\n// Chen Node moi vao cay\nNode *insertNode(Node *root_85, Node *p_85, int x_85)\n{\n    if (root_85 == NULL)\n    {\n        Node *node_85 = newNode(root_85, x_85);\n        return node_85;\n    }\n    Node *l_85 = p_85->leftMostChild_85;\n    if (l_85 == NULL)\n    {\n        p_85->leftMostChild_85 = newNode(root_85, x_85);\n        return root_85;\n    }\n    while (l_85->rightSibling_85 != NULL)\n    {\n        l_85 = l_85->rightSibling_85;\n    }\n    l_85->rightSibling_85 = newNode(root_85, x_85);\n    return root_85;\n}\n\n// In ra cay theo InOrder\nvoid printInOrder(Node *root_85)\n{\n    if (root_85 == NULL)\n        return;\n    Node *p_85 = root_85->leftMostChild_85;\n    printInOrder(p_85);\n\n    cout << root_85->data_85 << \" \";\n\n    if (p_85 != NULL)\n        p_85 = p_85->rightSibling_85;\n\n    while (p_85 != NULL)\n    {\n        printInOrder(p_85);\n        p_85 = p_85->rightSibling_85;\n    }\n}\n\n// In ra cay theo PreOrder\nvoid printPreOrder(Node *root_85)\n{\n    if (root_85 == NULL)\n        return;\n    cout << root_85->data_85 << \" \";\n    Node *p_85 = root_85->leftMostChild_85;\n    while (p_85 != NULL)\n    {\n        printPreOrder(p_85);\n        p_85 = p_85->rightSibling_85;\n    }\n}\n\n// In ra cay theo PostOrder\nvoid printPostOrder(Node *root_85)\n{\n    if (root_85 == NULL)\n        return;\n    Node *p_85 = root_85->leftMostChild_85;\n    while (p_85 != NULL)\n    {\n        printPostOrder(p_85);\n        p_85 = p_85->rightSibling_85;\n    }\n    cout << root_85->data_85 << \" \";\n}\n\nint main()\n{\n    string s_85;\n    Node *root_85 = initNode();\n\n    do\n    {\n        cin >> s_85;\n        // Tao Node moi\n        if (s_85 == \"MakeRoot\")\n        {\n            int u_85;\n            cin >> u_85;\n            root_85 = newNode(root_85, u_85);\n        }\n        // Chen Node moi vao cay\n        else if (s_85 == \"Insert\")\n        {\n            int u_85, v_85;\n            cin >> u_85 >> v_85;\n\n            Node *node = findNode(root_85, v_85);\n            root_85 = insertNode(root_85, node, u_85);\n        }\n        // In ra cay theo PreOrder\n        else if (s_85 == \"PreOrder\")\n        {\n            printPreOrder(root_85);\n            cout << endl;\n        }\n        // In ra cay theo InOrder\n        else if (s_85 == \"InOrder\")\n        {\n            printInOrder(root_85);\n            cout << endl;\n        }\n        // In ra cay theo PostOrder\n        else if (s_85 == \"PostOrder\")\n        {\n            printPostOrder(root_85);\n            cout << endl;\n        }\n    } while (s_85 != \"*\");\n}"
        },
        "Bai6": {
            "Problem": "Problem: Week 3 - Family Tree\n\nDescription\nGiven a family tree represented by child-parent (c,p) relations in which c is a child of p. Perform queries about the family tree:\ndescendants <name>: return number of descendants of the given <name>\ngeneration <name>: return the number of generations of the descendants of the given <name>\nNote that: the total number of people in the family is less than or equal to 10\n4\n\nInput\nContains two blocks. The first block contains information about child-parent, including lines (terminated by a line containing ***), each line contains: <child> <parent> where <child> is a string represented the name of the child and <parent> is a string represented the name of the parent. The second block contains lines (terminated by a line containing ***), each line contains two string <cmd> and <param> where <cmd> is the command (which can be descendants or generation) and <param> is the given name of the person participating in the  query.\nOutput\nEach line is the result of a corresponding query.\n\nExample\nInput\nPeter Newman\nMichael Thomas\nJohn David\nPaul Mark\nStephan Mark\nPierre Thomas\nMark Newman\nBill David\nDavid Newman\nThomas Mark\n***\ndescendants Newman\ndescendants Mark\ndescendants David\ngeneration Mark\n***\nOutput\n10\n5\n2\n2",
            "Code": "// Phung Manh Hoang 20215385\n// Problem: Family Tree\n\n#include <iostream>\n\nusing namespace std;\n\n// Tao cau truc Node\ntypedef struct Node\n{\n    string name_85;\n    Node *leftMostChild_85;\n    Node *rightSibling_85;\n} Node;\n\n// Khoi tao Node\nNode *initNode()\n{\n    Node *root_85 = NULL;\n    return root_85;\n}\n\n// Tao Node moi\nNode *newNode(Node *root_85, string name_85)\n{\n    Node *node_85 = new Node;\n    node_85->name_85 = name_85;\n    node_85->leftMostChild_85 = NULL;\n    node_85->rightSibling_85 = NULL;\n    return node_85;\n}\n\n// Tim Node co gia tri name\nNode *findNode(Node *root_85, string name_85)\n{\n    if (root_85 == NULL)\n        return NULL;\n    if (root_85->name_85 == name_85)\n        return root_85;\n    Node *p_85 = root_85->leftMostChild_85;\n    while (p_85 != NULL)\n    {\n        Node *q_85 = findNode(p_85, name_85);\n        if (q_85 != NULL)\n            return q_85;\n        p_85 = p_85->rightSibling_85;\n    }\n    return NULL;\n}\n\n// Chen Node moi vao cay\nNode *insertNode(Node *root_85, Node *p_85, string name_85)\n{\n    if (root_85 == NULL)\n    {\n        Node *node = newNode(root_85, name_85);\n        return node;\n    }\n    Node *l_85 = p_85->leftMostChild_85;\n    if (l_85 == NULL)\n    {\n        p_85->leftMostChild_85 = newNode(root_85, name_85);\n        return root_85;\n    }\n    while (l_85->rightSibling_85 != NULL)\n    {\n        l_85 = l_85->rightSibling_85;\n    }\n    l_85->rightSibling_85 = newNode(root_85, name_85);\n    return root_85;\n}\n\n// Dem so node con cua 1 node\nint countNode(Node *root_85)\n{\n    if (root_85 == NULL)\n        return 0;\n    int count_85 = 1;\n    Node *p_85 = root_85->leftMostChild_85;\n    while (p_85 != NULL)\n    {\n        count_85 += countNode(p_85);\n        p_85 = p_85->rightSibling_85;\n    }\n    return count_85;\n}\n\n// Tim chieu cao cua 1 node\nint height(Node *root_85)\n{\n    if (root_85 == NULL)\n        return 0;\n    int h_85 = 0;\n    Node *p_85 = root_85->leftMostChild_85;\n    while (p_85 != NULL)\n    {\n        h_85 = max(h_85, height(p_85));\n        p_85 = p_85->rightSibling_85;\n    }\n    return h_85 + 1;\n}\n\n// Kiem tra 1 node co phai la con cua 1 node khac hay khong\nbool isChild_85(Node *parent_85, string nameChild_85)\n{\n    if (parent_85 == NULL)\n        return false;\n    Node *p_85 = parent_85->leftMostChild_85;\n    while (p_85 != NULL)\n    {\n        if (p_85->name_85 == nameChild_85)\n            return true;\n        p_85 = p_85->rightSibling_85;\n    }\n    return false;\n}\n\n// Them 1 node vao cuoi cua 1 node khac\nNode *addNode(Node *root_85, Node *parent_85, Node *child_85)\n{\n    if (root_85 == NULL)\n        return NULL;\n\n    Node *l_85 = parent_85->leftMostChild_85;\n    if (l_85 == NULL)\n    {\n        parent_85->leftMostChild_85 = child_85;\n        return root_85;\n    }\n    while (l_85->rightSibling_85 != NULL)\n    {\n        l_85 = l_85->rightSibling_85;\n    }\n    l_85->rightSibling_85 = child_85;\n    return root_85;\n}\n\n// Chuyen 1 node tu vi tri hien tai sang vi tri moi\nNode *transferNode(Node *root_85, Node *parent_85, string nameChild_85)\n{\n    if (root_85 == NULL)\n        return NULL;\n    if (isChild_85(parent_85, nameChild_85))\n        return root_85;\n\n    Node *l_85 = root_85->leftMostChild_85;\n\n    while (l_85 != NULL)\n    {\n        if (l_85->rightSibling_85->name_85 == nameChild_85)\n        {\n            Node *p_85 = l_85->rightSibling_85;\n            l_85->rightSibling_85 = l_85->rightSibling_85->rightSibling_85;\n            p_85->rightSibling_85 = NULL;\n            root_85 = addNode(root_85, parent_85, p_85);\n            return root_85;\n        }\n        else\n            l_85 = l_85->rightSibling_85;\n    }\n\n    return root_85;\n}\n\nint main()\n{\n    string nameChild_85, nameParent_85;\n    Node *root_85 = initNode();\n\n    while (true)\n    {\n        cin >> nameChild_85;\n        if (nameChild_85 == \"***\")\n            break;\n        cin >> nameParent_85;\n\n        // Khoi tao cay va them node moi\n        if (root_85 == NULL)\n        {\n            root_85 = newNode(root_85, nameParent_85);\n            root_85 = insertNode(root_85, root_85, nameChild_85);\n        }\n        else\n        {\n            Node *parent_85 = findNode(root_85, nameParent_85);\n            Node *child_85 = findNode(root_85, nameChild_85);\n            if (parent_85 == NULL)\n            {\n                root_85 = insertNode(root_85, root_85, nameParent_85);\n                Node *p = findNode(root_85, nameParent_85);\n                if (child_85 == NULL)\n                {\n\n                    root_85 = insertNode(root_85, p, nameChild_85);\n                }\n                else\n                {\n                    root_85 = transferNode(root_85, p, nameChild_85);\n                }\n            }\n            else\n            {\n                if (child_85 == NULL)\n                {\n                    root_85 = insertNode(root_85, parent_85, nameChild_85);\n                }\n                else\n                {\n                    root_85 = transferNode(root_85, parent_85, nameChild_85);\n                }\n            }\n        }\n    }\n\n    string cmd_85, param_85;\n\n    do\n    {\n        cin >> cmd_85;\n        if (cmd_85 == \"***\")\n            break;\n        // In ra so Node con cua 1 Node\n        if (cmd_85 == \"descendants\")\n        {\n            cin >> param_85;\n            cout << countNode(findNode(root_85, param_85)) - 1 << endl;\n        }\n        // In ra chieu cao cua 1 Node\n        else if (cmd_85 == \"generation\")\n        {\n            cin >> param_85;\n            cout << height(findNode(root_85, param_85)) - 1 << endl;\n        }\n\n    } while (cmd_85 != \"***\");\n}"
        },
        "Bai7": {
            "Problem": "Problem: Week 3 - BST - Insertion and PreOrder Traversal\n\nDescription\nGiven a BST initialized by NULL. Perform a sequence of operations on a BST including:\ninsert k: insert a key k into the BST (do not insert if the key k exists)\nInput\n\u2022Each line contains command under the form: \u201cinsert k\u201d\n\u2022The input is terminated by a line containing #\nOutput\n\u2022Write the sequence of keys of nodes visited by the pre-order traversal (separated by a SPACE character)\n\nExample\nInput\ninsert 20\ninsert 10\ninsert 26\ninsert 7\ninsert 15\ninsert 23\ninsert 30\ninsert 3\ninsert 8\n#\nOutput\n20 10 7 3 8 15 26 23 30\n",
            "Code": "// Phung Manh Hoang 20215385\n// Problem: BST - Insertion and PreOrder Traversal\n\n#include <iostream>\n\nusing namespace std;\n\n// Tao cau truc Tree\ntypedef struct BinaryTree\n{\n    int data_85;\n    BinaryTree *left_85;\n    BinaryTree *right_85;\n} Tree;\n\n// Khoi tao Tree\nTree *initTree()\n{\n    Tree *root_85 = NULL;\n    return root_85;\n}\n\n// Tao Node moi\nTree *newNode(Tree *root_85, int x_85)\n{\n    Tree *Node_85 = new Tree;\n    Node_85->data_85 = x_85;\n    Node_85->left_85 = NULL;\n    Node_85->right_85 = NULL;\n    return Node_85;\n}\n\n// Chen Node moi vao cay\nTree *insertNode(Tree *root_85, int x_85)\n{\n    if (root_85 == NULL)\n    {\n        Tree *Node_85 = newNode(root_85, x_85);\n        return Node_85;\n    }\n\n    if (x_85 <= root_85->data_85)\n    {\n        root_85->left_85 = insertNode(root_85->left_85, x_85);\n    }\n    else\n    {\n        root_85->right_85 = insertNode(root_85->right_85, x_85);\n    }\n    return root_85;\n}\n\n// Duyet cay theo thu tu truoc\nvoid printPreOrder(Tree *root_85)\n{\n    if (root_85 == NULL)\n    {\n        return;\n    }\n\n    cout << root_85->data_85 << \" \";\n    printPreOrder(root_85->left_85);\n    printPreOrder(root_85->right_85);\n}\n\n// Tim Node co gia tri x\nbool findNode(Tree *root_85, int x_85)\n{\n    if (root_85 == NULL)\n    {\n        return false;\n    }\n\n    if (root_85->data_85 == x_85)\n    {\n        return true;\n    }\n\n    if (x_85 <= root_85->data_85)\n    {\n        return findNode(root_85->left_85, x_85);\n    }\n    else\n    {\n        return findNode(root_85->right_85, x_85);\n    }\n}\n\n// Xoa cay\nvoid deleteTree(Tree *root_85)\n{\n    if (root_85 == nullptr)\n    {\n        return;\n    }\n\n    deleteTree(root_85->left_85);\n    deleteTree(root_85->right_85);\n    delete root_85;\n}\n\nint main()\n{\n    Tree *root_85 = initTree();\n    string s_85;\n\n    do\n    {\n        cin >> s_85;\n        if (s_85 == \"#\")\n            break;\n        // Chen Node moi vao cay\n        if (s_85 == \"insert\")\n        {\n            int x_85;\n            cin >> x_85;\n            if (findNode(root_85, x_85) == false)\n            {\n                root_85 = insertNode(root_85, x_85);\n            }\n        }\n    } while (s_85 != \"#\");\n\n    printPreOrder(root_85);\n    deleteTree(root_85);\n}"
        },
        "Bai8": {
            "Problem": "Problem: Insert at the middle of a sequence\n\nDescription\nGiven a sequence of integers a1, a2, ..., an. The element in the middle is defined to be the element at index n/2 if n is even, and n/2+1, otherwise.\nPerform a sequence of actions of the form:\nADD v: which add a value v right-after the element in the middle of an sequence a1, a2, ..., an. \nPRINT: print the sequence to stdout, elements are separated by a SPACE character\n \nInput\nLine 1: contains a positive integer n (1 <= n <= 100000)\nLine 2: contains n positive integers a1, a2, ..., an (1 <= ai <= 1000000)\nSubsequent lines (number of lines can be up to 100000), each line contains an action of above format\n\nOutput\nWrite (in each line) the result of the corresponding PRINT action\n\nExample\nInput \n2\n8 4 \nADD 6\nADD 5\nADD 4\nPRINT\nADD 2\nADD 4\nPRINT\n#\n\nOutput\n8 6 4 5 4\n8 6 4 4 2 5 4\n ",
            "Code": "// Phung Manh Hoang 20215385\n// Problem: Insert at the middle of a sequence\n\n#include <iostream>\n\nusing namespace std;\n\n// Tao cau truc Node\nstruct Node\n{\n    int data_85;\n    Node *next_85;\n};\n\n// Tao Node danh dau\nNode *mark_85 = NULL;\n\n// Khoi tao Head\nNode *initHead()\n{\n    Node *head_85 = NULL;\n    return head_85;\n}\n\n// Tao Node moi\nNode *newNode(int value_85)\n{\n    Node *temp_85;\n    temp_85 = new Node;\n    temp_85->next_85 = NULL;\n    temp_85->data_85 = value_85;\n    return temp_85;\n}\n\n// Chen Node moi vao dau\nNode *addHead(Node *head_85, int value_85)\n{\n    Node *temp_85 = newNode(value_85);\n    if (head_85 == NULL)\n    {\n        return temp_85;\n    }\n    temp_85->next_85 = head_85;\n    return temp_85;\n}\n\n// Chen Node moi vao cuoi\nNode *addTail(Node *head_85, int value_85)\n{\n    Node *temp_85 = newNode(value_85);\n    if (head_85 == NULL)\n    {\n        return temp_85;\n    }\n    Node *p_85 = head_85;\n    while (p_85->next_85 != NULL)\n    {\n        p_85 = p_85->next_85;\n    }\n    p_85->next_85 = temp_85;\n    return head_85;\n}\n\n// Chen Node moi vao vi tri giua\nNode *addAt(Node *head_85, int value_85, int n_85)\n{\n    if (n_85 % 2 == 0)\n    {\n        int index_85 = n_85 / 2;\n        if (index_85 == 0)\n        {\n            head_85 = addHead(head_85, value_85);\n            mark_85 = head_85;\n            return head_85;\n        }\n        Node *temp_85 = newNode(value_85);\n        if (head_85 == NULL)\n        {\n            mark_85 = temp_85;\n            return temp_85;\n        }\n        int i_85 = 1;\n        Node *p_85 = head_85;\n        while (i_85 != index_85)\n        {\n            p_85 = p_85->next_85;\n            i_85++;\n        }\n        temp_85->next_85 = p_85->next_85;\n        p_85->next_85 = temp_85;\n        mark_85 = p_85->next_85;\n        return head_85;\n    }\n    else\n    {\n        int index_85 = n_85 / 2 + 1;\n        Node *temp_85 = newNode(value_85);\n        int i_85 = 1;\n        Node *p_85 = head_85;\n        while (i_85 != index_85)\n        {\n            p_85 = p_85->next_85;\n            i_85++;\n        }\n        temp_85->next_85 = p_85->next_85;\n        p_85->next_85 = temp_85;\n        mark_85 = p_85;\n        return head_85;\n    }\n}\n\n// Chen Node moi vao vi tri danh dau\nNode *addMark(Node *head_85, int value_85, int n_85)\n{\n    Node *temp_85 = newNode(value_85);\n    temp_85->next_85 = mark_85->next_85;\n    mark_85->next_85 = temp_85;\n    if (n_85 % 2 == 0)\n        mark_85 = mark_85->next_85;\n    else\n        mark_85 = mark_85;\n    return head_85;\n}\n\n// In ra danh sach\nvoid printNode(Node *head_85)\n{\n    Node *p_85 = head_85;\n\n    while (p_85 != NULL)\n    {\n        cout << p_85->data_85 << \" \";\n        p_85 = p_85->next_85;\n    }\n    cout << endl;\n}\n\n// Giai phong bo nho\nvoid freeNode(Node *head_85)\n{\n    Node *p_85 = head_85;\n    while (p_85 != NULL)\n    {\n        Node *temp_85 = p_85;\n        p_85 = p_85->next_85;\n        delete temp_85;\n    }\n}\n\nint main()\n{\n    int n_85;\n    Node *head_85 = initHead();\n    cin >> n_85;\n\n    // Khoi tao cay va them node\n    for (int i = 0; i < n_85; i++)\n    {\n        int value_85;\n        cin >> value_85;\n        head_85 = addTail(head_85, value_85);\n    }\n\n    string s_85;\n    do\n    {\n        cin >> s_85;\n        if (s_85 == \"#\")\n        {\n            break;\n        }\n        // Chen Node moi vao vi tri giua\n        else if (s_85 == \"ADD\")\n        {\n            int x_85;\n            cin >> x_85;\n            if (mark_85 == NULL)\n            {\n                head_85 = addAt(head_85, x_85, n_85);\n                n_85++;\n            }\n            else\n            {\n                head_85 = addMark(head_85, x_85, n_85);\n                n_85++;\n            }\n        }\n        else if (s_85 == \"PRINT\")\n        {\n            printNode(head_85);\n        }\n    } while (s_85 != \"#\");\n\n    freeNode(head_85);\n}"
        },
        "Bai9": {
            "Problem": "Problem: Week 3 - Linked List Manipulation\n\nDescription\nVi\u1ebft ch\u01b0\u01a1ng tr\u00ecnh th\u1ef1c hi\u1ec7n c\u00f4ng vi\u1ec7c sau:\nX\u00e2y d\u1ef1ng danh s\u00e1ch li\u00ean k\u1ebft v\u1edbi c\u00e1c kh\u00f3a \u0111\u01b0\u1ee3c cung c\u1ea5p ban \u0111\u1ea7u l\u00e0 d\u00e3y a1, a2, \u2026, an, sau \u0111\u00f3 th\u1ef1c hi\u1ec7n c\u00e1c thao t\u00e1c tr\u00ean danh s\u00e1ch bao g\u1ed3m: th\u00eam 1 ph\u1ea7n t\u1eed v\u00e0o \u0111\u1ea7u, v\u00e0o cu\u1ed1i danh s\u00e1ch, ho\u1eb7c v\u00e0o tr\u01b0\u1edbc, v\u00e0o sau 1 ph\u1ea7n t\u1eed n\u00e0o \u0111\u00f3 trong danh s\u00e1ch, ho\u1eb7c lo\u1ea1i b\u1ecf 1 ph\u1ea7n t\u1eed n\u00e0o \u0111\u00f3 trong danh s\u00e1ch\n\nInput\nD\u00f2ng 1: ghi s\u1ed1 nguy\u00ean d\u01b0\u01a1ng n (1 <= n <= 1000)\nD\u00f2ng 2: ghi c\u00e1c s\u1ed1 nguy\u00ean d\u01b0\u01a1ng a1, a2, \u2026, an.\nC\u00e1c d\u00f2ng ti\u1ebfp theo l\u1ea7n l\u01b0\u1ee3t l\u00e0 c\u00e1c l\u1ec7nh \u0111\u1ec3 thao t\u00e1c (k\u1ebft th\u00fac b\u1edfi k\u00fd hi\u1ec7u #) v\u1edbi c\u00e1c lo\u1ea1i sau:\naddlast  k: th\u00eam ph\u1ea7n t\u1eed c\u00f3 key b\u1eb1ng k v\u00e0o cu\u1ed1i danh s\u00e1ch (n\u1ebfu k ch\u01b0a t\u1ed3n t\u1ea1i)\naddfirst  k: th\u00eam ph\u1ea7n t\u1eed c\u00f3 key b\u1eb1ng k v\u00e0o \u0111\u1ea7u danh s\u00e1ch (n\u1ebfu k ch\u01b0a t\u1ed3n t\u1ea1i)\naddafter  u  v: th\u00eam ph\u1ea7n t\u1eed c\u00f3 key b\u1eb1ng u v\u00e0o sau ph\u1ea7n t\u1eed c\u00f3 key b\u1eb1ng v tr\u00ean danh s\u00e1ch (n\u1ebfu v \u0111\u00e3 t\u1ed3n t\u1ea1i tr\u00ean danh s\u00e1ch v\u00e0 u ch\u01b0a t\u1ed3n t\u1ea1i)\naddbefore  u  v: th\u00eam ph\u1ea7n t\u1eed c\u00f3 key b\u1eb1ng  u v\u00e0o tr\u01b0\u1edbc ph\u1ea7n t\u1eed c\u00f3 key b\u1eb1ng v tr\u00ean danh s\u00e1ch (n\u1ebfu v \u0111\u00e3 t\u1ed3n t\u1ea1i tr\u00ean danh s\u00e1ch v\u00e0 u c\u1ee7a t\u1ed3n t\u1ea1i)\nremove  k: lo\u1ea1i b\u1ecf ph\u1ea7n t\u1eed c\u00f3 key b\u1eb1ng k kh\u1ecfi danh s\u00e1ch\nreverse: \u0111\u1ea3o ng\u01b0\u1ee3c th\u1ee9 t\u1ef1 c\u00e1c ph\u1ea7n t\u1eed c\u1ee7a danh s\u00e1ch (kh\u00f4ng \u0111\u01b0\u1ee3c c\u1ea5p ph\u00e1t m\u1edbi c\u00e1c ph\u1ea7n t\u1eed, ch\u1ec9 \u0111\u01b0\u1ee3c thay \u0111\u1ed5i m\u1ed1i n\u1ed1i li\u00ean k\u1ebft)\nOutput\nGhi ra d\u00e3y kh\u00f3a c\u1ee7a danh s\u00e1ch thu \u0111\u01b0\u1ee3c sau 1 chu\u1ed7i c\u00e1c l\u1ec7nh thao t\u00e1c \u0111\u00e3 cho\n\nExample\nInput\n5\n5 4 3 2 1\naddlast 3\naddlast 10\naddfirst 1\naddafter 10 4\nremove 1\n#\n\nOutput\n5 4 3 2 10 ",
            "Code": "// Phung Manh Hoang 20215385\n// Problem: Linked List Manipulation\n\n#include <iostream>\n\nusing namespace std;\n\n// Tao cau truc Node\nstruct Node\n{\n    int data_85;\n    Node *next_85;\n};\n\n// Khoi tao Head\nNode *initHead()\n{\n    Node *head_85 = NULL;\n    return head_85;\n}\n\n// Tao Node moi\nNode *newNode(int value_85)\n{\n    Node *temp_85;\n    temp_85 = new Node;\n    temp_85->next_85 = NULL;\n    temp_85->data_85 = value_85;\n    return temp_85;\n}\n\n// Chen Node moi vao dau\nNode *addHead(Node *head_85, int value_85)\n{\n    Node *temp_85 = newNode(value_85);\n    if (head_85 == NULL)\n    {\n        return temp_85;\n    }\n    temp_85->next_85 = head_85;\n    return temp_85;\n}\n\n// Chen Node moi vao cuoi\nNode *addTail(Node *head_85, int value_85)\n{\n    Node *temp_85 = newNode(value_85);\n    if (head_85 == NULL)\n    {\n        return temp_85;\n    }\n    Node *p_85 = head_85;\n    while (p_85->next_85 != NULL)\n    {\n        p_85 = p_85->next_85;\n    }\n    p_85->next_85 = temp_85;\n    return head_85;\n}\n\n// Chen Node moi vao sau Node co gia tri u\nNode *addAfter(Node *head_85, int u_85, int v_85)\n{\n    Node *temp_85 = newNode(u_85);\n    if (head_85 == NULL)\n    {\n        return head_85;\n    }\n    Node *p_85 = head_85;\n    while (p_85 != NULL)\n    {\n        if (p_85->data_85 == v_85)\n        {\n            temp_85->next_85 = p_85->next_85;\n            p_85->next_85 = temp_85;\n            return head_85;\n        }\n        p_85 = p_85->next_85;\n    }\n    return head_85;\n}\n\n// Chen Node moi vao truoc Node co gia tri u\nNode *addBefore(Node *head_85, int u_85, int v_85)\n{\n    Node *temp_85 = newNode(u_85);\n    if (head_85 == NULL)\n    {\n        return head_85;\n    }\n    if (head_85->data_85 == v_85)\n    {\n        temp_85->next_85 = head_85;\n        return temp_85;\n    }\n    Node *p_85 = head_85;\n    while (p_85->next_85 != NULL)\n    {\n        if (p_85->next_85->data_85 == v_85)\n        {\n            temp_85->next_85 = p_85->next_85;\n            p_85->next_85 = temp_85;\n            return head_85;\n        }\n        p_85 = p_85->next_85;\n    }\n    return head_85;\n}\n\n// Xoa Node co gia tri value\nNode *remode(Node *head_85, int value_85)\n{\n    if (head_85 == NULL)\n    {\n        return head_85;\n    }\n    if (head_85->data_85 == value_85)\n    {\n        return head_85->next_85;\n    }\n    Node *p_85 = head_85;\n    while (p_85->next_85 != NULL)\n    {\n        if (p_85->next_85->data_85 == value_85)\n        {\n            p_85->next_85 = p_85->next_85->next_85;\n            return head_85;\n        }\n        p_85 = p_85->next_85;\n    }\n    return head_85;\n}\n\n// Tim Node co gia tri  value\nbool findNode(Node *head_85, int value_85)\n{\n    Node *p_85 = head_85;\n    while (p_85 != NULL)\n    {\n        if (p_85->data_85 == value_85)\n        {\n            return true;\n        }\n        p_85 = p_85->next_85;\n    }\n    return false;\n}\n\n// In ra danh sach\nvoid printNode(Node *head_85)\n{\n    Node *p_85 = head_85;\n\n    while (p_85 != NULL)\n    {\n        cout << p_85->data_85 << \" \";\n        p_85 = p_85->next_85;\n    }\n    cout << \"\\n\";\n}\n\n// Dao nguoc danh sach\nNode *reverseNode(Node *head_85)\n{\n    if (head_85 == NULL || head_85->next_85 == NULL)\n    {\n        return head_85;\n    }\n    Node *i_85 = NULL, *j_85 = head_85, *k_85 = head_85->next_85;\n    while (j_85 != NULL)\n    {\n        j_85->next_85 = i_85;\n        i_85 = j_85;\n        j_85 = k_85;\n        if (j_85 != NULL)\n            k_85 = j_85->next_85;\n    }\n    return i_85;\n}\n\n// Giai phong danh sach\nvoid freeNode(Node *head_85)\n{\n    Node *p_85 = head_85;\n    while (p_85 != NULL)\n    {\n        head_85 = head_85->next_85;\n        delete p_85;\n        p_85 = head_85;\n    }\n}\n\nint main()\n{\n    int n_85, x_85;\n    Node *head_85 = initHead();\n\n    cin >> n_85;\n    for (int i = 0; i < n_85; i++)\n    {\n        cin >> x_85;\n        head_85 = addTail(head_85, x_85);\n    }\n\n    string s_85;\n    do\n    {\n        cin >> s_85;\n        if (s_85 == \"#\")\n            break;\n        // Chen Node moi vao vi tri cuoi\n        if (s_85 == \"addlast\")\n        {\n            cin >> x_85;\n            if (!findNode(head_85, x_85))\n                head_85 = addTail(head_85, x_85);\n        }\n        // Chen Node moi vao vi tri dau\n        else if (s_85 == \"addfirst\")\n        {\n            cin >> x_85;\n            if (!findNode(head_85, x_85))\n                head_85 = addHead(head_85, x_85);\n        }\n        // Chen Node moi vao sau Node co gia tri x\n        else if (s_85 == \"addafter\")\n        {\n            int y_85;\n            cin >> x_85 >> y_85;\n            if (!findNode(head_85, x_85) && findNode(head_85, y_85))\n                head_85 = addAfter(head_85, x_85, y_85);\n        }\n        // Chen Node moi vao truoc Node co gia tri x\n        else if (s_85 == \"addbefore\")\n        {\n            int y_85;\n            cin >> x_85 >> y_85;\n            if (!findNode(head_85, x_85) && findNode(head_85, y_85))\n                head_85 = addBefore(head_85, x_85, y_85);\n        }\n        // Xoa Node co gia tri x\n        else if (s_85 == \"remove\")\n        {\n            cin >> x_85;\n            head_85 = remode(head_85, x_85);\n        }\n        // Dao nguoc danh sach\n        else if (s_85 == \"reverse\")\n        {\n            head_85 = reverseNode(head_85);\n        }\n    } while (s_85 != \"#\");\n\n    printNode(head_85);\n    freeNode(head_85);\n}"
        }
    },
    "Tuần 4": {
        "Bai1": {
            "Problem": "Problem: Week 4 - Store & Search String\n\nDescription\nA database contains a sequence of key k1, k2, ..., kn which are strings (1<=n<=100000). Perform a sequence of actions of two kinds:\n\u00b7 find k: find and return 1 if k exists in the database, and return 0, otherwise\n\u00b7 insert k: insert a key k into the database and return 1 if the insertion is successful (k does not exist in the database) and return 0 if the insertion is failed (k exists in the database)\nNote that the length of any key is greater than 0 and less than or equal to 50.\n\nInput\nTwo blocks of information. The first block contains a key of (k1,k2,...,kn) in each line. The first block is terminated with a line containing *. The second block is a sequence of actions of two finds described above: each line contains 2 string: cmd and k in which cmd = find or insert and k is the key (parameter of the action). The second block is terminated with a line containing ***. Note that the number of actions can be up to 100000.\nOutput\nEach line contains the result (0 or 1) of the corresponding action.\n\nExample\nInput\ncomputer\nuniversity\nschool\ntechnology\nphone\n*\nfind school\nfind book\ninsert book\nfind algorithm\nfind book\ninsert book\n***\nOutput\n1\n0\n1\n0\n1\n0",
            "Code": "// Phung Manh Hoang 20215385\n// Problem: Store & Search String\n\n#include <iostream>\n#include <map>\n\nusing namespace std;\n\nint main()\n{\n    map<string, int> mapKey_85;\n    string s_85;\n\n    // Nhap cac key vao map\n    while (true)\n    {\n        cin >> s_85;\n        if (s_85 == \"*\")\n            break;\n        mapKey_85[s_85] = 1;\n    }\n\n    // Thuc hien truy van\n    while (true)\n    {\n        cin >> s_85;\n        if (s_85 == \"***\")\n            break;\n        // Kiem tra xem co ton tai keytrong map hay khong\n        if (s_85 == \"find\")\n        {\n            string key_85;\n            cin >> key_85;\n\n            if (mapKey_85.count(key_85) > 0)\n                cout << \"1\" << endl;\n            else\n                cout << \"0\" << endl;\n        }\n        // Them key vao map\n        else if (s_85 == \"insert\")\n        {\n            string key_85;\n            cin >> key_85;\n\n            if (mapKey_85.count(key_85) > 0)\n                cout << \"0\" << endl;\n            else\n            {\n                mapKey_85[key_85] = 1;\n                cout << \"1\" << endl;\n            }\n        }\n    }\n}"
        },
        "Bai2": {
            "Problem": "Problem: Week 4 - Hash Over Strings\n\nDescription\nGiven a string s[1\u2026k] which is a sequence of characters taken from {\u2018a\u2019, . . ., \u2018z\u2019}. Given a positive integer m, the hash code of s is defined by the formula:\nH(s) =  (s[1]*256k-1 + s[2]*256k-2 + . . . + s[k]*2560 ) mod m  (the contant integer m is a parameter)\nGiven a sequence of strings k1, k2, \u2026, kn, compute the corresponding hash codes\n\nInput\nLine 1: n and m (1 <= n,m <= 100000)\nLine i+1 (i = 1,2,\u2026,n): contains the string ki (the length of each string is less than or equal to 200)\nOutput\nEach line contains the corresponding hash code of n given strings\n\nExample\nInput\n4 1000\na\nab\nabc\nabcd\nOutput\n97\n930\n179\n924",
            "Code": "// Phung Manh Hoang 20215385\n// Problem: Hash Over Strings\n\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Tinh luy thua 256^n % m\nvoid pow(vector<int> &vecPow_85, int m_85)\n{\n    vecPow_85.push_back(1);\n    for (int i = 1; i < 220; i++)\n    {\n        vecPow_85.push_back((vecPow_85[i - 1] * 256) % m_85);\n    }\n}\n\nint main()\n{\n    vector<int> vecPow_85;\n    int n_85, m_85, H_85 = 0;\n    string s_85;\n\n    cin >> n_85 >> m_85;\n\n    pow(vecPow_85, m_85);\n\n    // Tinh ma bam cua tung xau\n    for (int i = 0; i < n_85; i++)\n    {\n        cin >> s_85;\n        int size_85 = s_85.size() - 1;\n        for (auto j : s_85)\n        {\n            H_85 += ((j % m_85) * vecPow_85[size_85]) % m_85;\n            size_85--;\n        }\n        cout << H_85 % m_85 << endl;\n        H_85 = 0;\n    }\n}"
        },
        "Bai3": {
            "Problem": "Problem: Week 4 - Ki\u1ec3m tra xu\u1ea5t hi\u1ec7n\n\nDescription\nCho d\u00e3y s\u1ed1 nguy\u00ean A1, A2, . . . , An v\u1edbi m\u1ed7i s\u1ed1 nguy\u00ean Ai ki\u1ec3m tra xem c\u00f3 s\u1ed1 Aj n\u00e0o b\u1eb1ng Ai hay kh\u00f4ng v\u1edbi j<i.\n\nInput\nD\u00f2ng \u0111\u1ea7u ch\u1ee9a s\u1ed1 n (1\u2264n\u2264100,000)\nD\u00f2ng hai ch\u1ee9a nn s\u1ed1 nguy\u00ean A1, A2, ..., An (1\u2264Ai\u22641000,000,000)\nOutput\nGhi ra n d\u00f2ng, d\u00f2ng th\u1ee9 i in ra 1 n\u1ebfu t\u1ed3n t\u1ea1i Aj=Ai v\u1edbi j<i, ng\u01b0\u1ee3c l\u1ea1i in ra 0.\n\nExample\ninput\n5\n1 4 3 1 4\noutput\n0\n0\n0\n1\n1",
            "Code": "// Phung Manh Hoang 20215385\n// Problem: Ki\u1ec3m tra xu\u1ea5t hi\u1ec7n\n#include <iostream>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\nint main()\n{\n    int n_85, x_85;\n    vector<int> vec_85;\n    map<int, int> check_85;\n\n    // Nhap vector ban dau\n    cin >> n_85;\n    for (int i = 0; i < n_85; i++)\n    {\n        cin >> x_85;\n        vec_85.push_back(x_85);\n        check_85[x_85] = 0;\n    }\n\n    // Kiem tra xem x co xuat hien trong vector ban dau hay khong\n    for (int i = 0; i < n_85; i++)\n    {\n        if (check_85[vec_85[i]] == 0)\n        {\n            cout << \"0\" << endl;\n            check_85[vec_85[i]] = 1;\n        }\n        else\n        {\n            cout << \"1\" << endl;\n        }\n    }\n}"
        },
        "Bai4": {
            "Problem": "Problem: Week 4 - Sum pair of sequence equal to a number\n\nDescription\nCho d\u00e3y a1, a2, ..., an trong \u0111\u00f3 c\u00e1c ph\u1ea7n t\u1eed \u0111\u00f4i m\u1ed9t kh\u00e1c nhau v\u00e0 1 gi\u00e1 tr\u1ecb nguy\u00ean d\u01b0\u01a1ng M. H\u00e3y \u0111\u1ebfm s\u1ed1 Q c\u00e1c c\u1eb7p (i,j) sao cho 1 <= i < j <= n v\u00e0 ai + aj = M.\n\nD\u1eef li\u1ec7u\nD\u00f2ng 1: ghi n v\u00e0 M (1 <= n, M <= 1000000)\nD\u00f2ng 2: ghi a1, a2, ..., an\nK\u1ebft qu\u1ea3\nGhi ra gi\u00e1 tr\u1ecb Q\n\nV\u00ed d\u1ee5\nD\u1eef li\u1ec7u\n5 6\n5 2 1 4 3\nK\u1ebft qu\u1ea3\n2",
            "Code": "// Phung Manh Hoang 20215385\n// Problem: Sum pair of sequence equal to a number\n\n#include <iostream>\n#include <map>\nusing namespace std;\n\nint main()\n{\n    int n_85, M_85;\n    cin >> n_85 >> M_85;\n    int a_85[n_85];\n    // Nhap mang ban dau\n    for (int i = 0; i < n_85; i++)\n    {\n        cin >> a_85[i];\n    }\n\n    // Dem so cap co tong bang M\n    map<int, int> hash_table_85;\n    int Q_85 = 0;\n    for (int i = 0; i < n_85; i++)\n    {\n        if (hash_table_85.find(M_85 - a_85[i]) != hash_table_85.end())\n        {\n            Q_85++;\n        }\n        hash_table_85[a_85[i]] = i;\n    }\n    cout << Q_85 << endl;\n}\n"
        }
    },
    "Tuần 5": {
        "Bai1": {
            "Problem": "Problem: Week 5 - Minimum Spanning Tree - Kruskal\n\nDescription\nGiven a undirected connected graph G=(V,E) where V={1,\u2026,N}. Each edge (u,v)\u2208E(u,v)\u2208E has weight w(u,v)w(u,v). Compute minimum spanning tree of G.\n\nInput\nLine 1: N and M (1\u2264N,M\u2264105) in which NN is the number of nodes and MM is the number of edges.\nLine i+1 (i=1,\u2026,M): contains 3 positive integers u, v, and w where w is the weight of edge (u,v)\nOutput\nWrite the weight of the minimum spanning tree found.\n\nExample\nInput\n5 8\n1 2 1\n1 3 4\n1 5 1\n2 4 2\n2 5 1\n3 4 3\n3 5 3\n4 5 2\nOutput\n7",
            "Code": "// Ph\u00f9ng M\u1ea1nh Ho\u00e0ng 20215385\n// Problem: Week 5 - Minimum Spanning Tree - Kruskal\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Edge // \u0110\u1ecbnh ngh\u0129a c\u1ea5u tr\u00fac Edge\n{\n    int u_85, v_85, w_85;\n};\n\nint parent_85[100000]; // M\u1ea3ng l\u01b0u tr\u1eef cha c\u1ee7a m\u1ed7i n\u00fat\nint hang_85[100000];   // M\u1ea3ng l\u01b0u tr\u1eef h\u1ea1ng c\u1ee7a m\u1ed7i n\u00fat\n\nint find(int u_85) // H\u00e0m t\u00ecm cha c\u1ee7a n\u00fat u_85\n{\n    if (parent_85[u_85] != u_85)\n        parent_85[u_85] = find(parent_85[u_85]);\n    return parent_85[u_85];\n}\n\n// H\u00e0m h\u1ee3p nh\u1ea5t 2 c\u00e2y ch\u1ee9a u v\u00e0 v,\n// Tr\u1ea3 v\u1ec1 false n\u1ebfu kh\u00f4ng th\u1ec3 h\u1ee3p nh\u1ea5t\nbool join(int u_85, int v_85)\n{\n    u_85 = find(u_85);\n    v_85 = find(v_85);\n    if (u_85 == v_85)\n        return false;\n    if (hang_85[u_85] == hang_85[v_85])\n        hang_85[u_85]++;\n    if (hang_85[u_85] < hang_85[v_85])\n        parent_85[u_85] = v_85;\n    else\n        parent_85[v_85] = u_85;\n    return true;\n}\n\nint main()\n{\n    ios::sync_with_stdio(false); // T\u1eaft \u0111\u1ed3ng b\u1ed9 gi\u1eefa C v\u00e0 C++ streams\n    cin.tie(0);                  // Kh\u00f4ng li\u00ean k\u1ebft cin v\u1edbi cout\n\n    int N_85, M_85; // Kh\u1edfi t\u1ea1o v\u00e0 nh\u1eadp v\u00e0o n v\u00e0 m\n    vector<Edge> edges_85;\n    cin >> N_85 >> M_85;\n\n    int u_85, v_85, w_85; // Kh\u1edfi t\u1ea1o v\u00e0 nh\u1eadp v\u00e0o c\u00e1c c\u1ea1nh\n    for (int i = 0; i < M_85; i++)\n    {\n        cin >> u_85 >> v_85 >> w_85;\n        Edge e = {u_85, v_85, w_85};\n        edges_85.push_back(e);\n    }\n\n    //  S\u1eafp x\u1ebfp c\u00e1c c\u1ea1nh theo th\u1ee9 t\u1ef1 t\u0103ng d\u1ea7n c\u1ee7a tr\u1ecdng s\u1ed1\n    sort(edges_85.begin(), edges_85.end(), [](Edge a, Edge b)\n         { return a.w_85 < b.w_85; });\n\n    int weight_85 = 0;              // Tr\u1ecdng s\u1ed1 nh\u1ecf nh\u1ea5t c\u1ee7a c\u00e2y khung\n    for (int i = 1; i <= N_85; i++) // Kh\u1edfi t\u1ea1o c\u00e1c gi\u00e1 gi\u00e1 tr\u1ecb c\u1ee7a m\u1ea3ng parent v\u00e0 hang\n    {\n        parent_85[i] = i;\n        hang_85[i] = 0;\n    }\n\n    // g\u1ecdi thu\u1eadt to\u00e1n Kuruskal \u0111\u1ec3 t\u00ecm c\u00e2y khung nh\u1ecf nh\u1ea5t\n    for (Edge &e : edges_85)\n    {\n        if (join(e.u_85, e.v_85))\n        {\n            weight_85 += e.w_85;\n        }\n    }\n\n    cout << weight_85; // In ra tr\u1ecdng s\u1ed1 nh\u1ecf nh\u1ea5t c\u1ee7a c\u00e2y khung\n}\n"
        },
        "Bai2": {
            "Problem": "Problem: Week 5 - List order of nodes visited by a DFS\n\nDescription\nGiven a undirected graph =(V,E) in which V = {1,2,..,n} is the set of nodes. Write a program that visit nodes of G by a DFS (consider a lexicorgraphic order of nodes).\n\nInput\nLine 1: contains 2 integers n and m (1 <= n,m <= 100000)\nLine i+1: contains u and v which are two end-points of the ith edge\n\nOutput\nSequence of nodes visited by DFS\n\nExample\nInput\n7 12\n1 2\n1 3\n2 3\n2 4\n2 7\n3 5 \n3 7\n4 5\n4 6\n4 7\n5 6\n5 7 \nOutput\n1 2 3 5 4 6 7",
            "Code": "// Ph\u00f9ng M\u1ea1nh Ho\u00e0ng 20215385\n// Problem: List order of nodes visited by a DFS\n\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Khai b\u00e1o m\u1ea3ng visited_85 \u0111\u1ec3 \u0111\u00e1nh d\u1ea5u c\u00e1c \u0111\u1ec9nh \u0111\u00e3 \u0111\u01b0\u1ee3c duy\u1ec7t\nbool visited_85[100000] = {false};\n\n// H\u00e0m dfs \u0111\u1ec3 duy\u1ec7t \u0111\u1ed3 th\u1ecb theo chi\u1ec1u s\u00e2u\nvoid dfs(vector<vector<int>> Edges_85, int u_85)\n{\n    // \u0110\u00e1nh d\u1ea5u \u0111\u1ec9nh u_85 \u0111\u00e3 \u0111\u01b0\u1ee3c duy\u1ec7t\n    visited_85[u_85] = true;\n    cout << u_85 << \" \";\n    int size_85 = Edges_85.size();\n    // Duy\u1ec7t qua c\u00e1c \u0111\u1ec9nh k\u1ec1 v\u1edbi u_85\n    for (int v_85 = 1; v_85 <= size_85; v_85++)\n    {\n        // N\u1ebfu c\u00f3 c\u1ea1nh n\u1ed1i t\u1eeb u_85 t\u1edbi v_85 v\u00e0 v_85 ch\u01b0a \u0111\u01b0\u1ee3c duy\u1ec7t th\u00ec ti\u1ebfp t\u1ee5c duy\u1ec7t\n        if (Edges_85[u_85][v_85] == 1 && visited_85[v_85] == false)\n        {\n            dfs(Edges_85, v_85);\n        }\n    }\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n_85, m_85;\n    cin >> n_85 >> m_85;\n\n    // Kh\u1edfi t\u1ea1o ma tr\u1eadn k\u1ec1 Edges_85\n    vector<vector<int>> Edges_85;\n    for (int i = 0; i <= n_85; i++)\n    {\n        vector<int> temp;\n        for (int j = 0; j <= n_85; j++)\n        {\n            temp.push_back(0);\n        }\n        Edges_85.push_back(temp);\n    }\n\n    int u_85, v_85;\n    // \u0110\u1ecdc danh s\u00e1ch c\u1ea1nh v\u00e0 c\u1eadp nh\u1eadt v\u00e0o ma tr\u1eadn k\u1ec1\n    for (int i = 1; i <= m_85; i++)\n    {\n        cin >> u_85 >> v_85;\n        Edges_85[u_85][v_85] = 1;\n        Edges_85[v_85][u_85] = 1;\n    }\n\n    // Duy\u1ec7t qua t\u1ea5t c\u1ea3 c\u00e1c \u0111\u1ec9nh, n\u1ebfu \u0111\u1ec9nh ch\u01b0a \u0111\u01b0\u1ee3c duy\u1ec7t th\u00ec ti\u1ebfn h\u00e0nh duy\u1ec7t DFS t\u1eeb \u0111\u1ec9nh \u0111\u00f3\n    for (int i = 1; i <= n_85; i++)\n    {\n        if (visited_85[i] == false)\n        {\n            dfs(Edges_85, i);\n        }\n    }\n}\n"
        },
        "Bai3": {
            "Problem": "Problem: Week 5 - Sequence of nodes visited by BFS\n\nDescription\nGiven undirected graph G = (V,E) in which V = {1, 2, ..., n} is the set of nodes, and E is the set of m edges.\nWrite a program that computes the sequence of nodes visited using a BFS algorithm (the nodes are considered in a lexicographic order)\n\nInput\nLine 1: contains 2 integers n and m which are the number of nodes and the number of edges\nLine i+1 (i = 1, ..., m): contains 2 positive integers u and v which are the end points of the ith edge\n\nOutput\nWrite the sequence of nodes visited by a BFS procedure (nodes a are separated by a SPACE character)\nExample\n\nInput\n6 7\n2 4\n1 3\n3 4\n5 6\n1 2\n3 5\n2 3\n\nOutput\n1 2 3 4 5 6",
            "Code": "// Ph\u00f9ng M\u1ea1nh Ho\u00e0ng 20215385\n// Problem: Sequence of nodes visited by BFS\n\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\n// Khai b\u00e1o m\u1ea3ng visited_85 \u0111\u1ec3 \u0111\u00e1nh d\u1ea5u c\u00e1c \u0111\u1ec9nh \u0111\u00e3 \u0111\u01b0\u1ee3c duy\u1ec7t\nbool visited_85[100000] = {false};\n\n// H\u00e0m bfs \u0111\u1ec3 duy\u1ec7t \u0111\u1ed3 th\u1ecb theo chi\u1ec1u r\u1ed9ng\nvoid bfs(vector<vector<int>> Edges_85, int u_85)\n{\n    // Kh\u1edfi t\u1ea1o h\u00e0ng \u0111\u1ee3i q\n    queue<int> q_85;\n    q_85.push(u_85);\n    visited_85[u_85] = true;\n    while (!q_85.empty())\n    {\n        int v_85 = q_85.front();\n        q_85.pop();\n        cout << v_85 << \" \";\n        int size_85 = Edges_85.size();\n        // Duy\u1ec7t qua c\u00e1c \u0111\u1ec9nh k\u1ec1 v\u1edbi v_85\n        for (int i = 1; i <= size_85; i++)\n        {\n            // N\u1ebfu c\u00f3 c\u1ea1nh n\u1ed1i t\u1eeb v_85 t\u1edbi i v\u00e0 i ch\u01b0a \u0111\u01b0\u1ee3c duy\u1ec7t th\u00ec ti\u1ebfp t\u1ee5c duy\u1ec7t\n            if (Edges_85[v_85][i] == 1 && visited_85[i] == false)\n            {\n                q_85.push(i);\n                visited_85[i] = true;\n            }\n        }\n    }\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n_85, m_85;\n    cin >> n_85 >> m_85;\n\n    // Kh\u1edfi t\u1ea1o ma tr\u1eadn k\u1ec1 Edges_85\n    vector<vector<int>> Edges_85;\n    for (int i = 0; i <= n_85; i++)\n    {\n        vector<int> temp_85;\n        for (int j = 0; j <= n_85; j++)\n        {\n            temp_85.push_back(0);\n        }\n        Edges_85.push_back(temp_85);\n    }\n\n    int u_85, v_85;\n    // \u0110\u1ecdc danh s\u00e1ch c\u1ea1nh v\u00e0 c\u1eadp nh\u1eadt v\u00e0o ma tr\u1eadn k\u1ec1\n    for (int i = 1; i <= m_85; i++)\n    {\n        cin >> u_85 >> v_85;\n        Edges_85[u_85][v_85] = 1;\n        Edges_85[v_85][u_85] = 1;\n    }\n\n    // Duy\u1ec7t qua t\u1ea5t c\u1ea3 c\u00e1c \u0111\u1ec9nh, n\u1ebfu \u0111\u1ec9nh ch\u01b0a \u0111\u01b0\u1ee3c duy\u1ec7t th\u00ec ti\u1ebfn h\u00e0nh duy\u1ec7t BFS t\u1eeb \u0111\u1ec9nh \u0111\u00f3\n    for (int i = 1; i <= n_85; i++)\n    {\n        if (visited_85[i] == false)\n        {\n            bfs(Edges_85, i);\n        }\n    }\n}\n"
        },
        "Bai4": {
            "Problem": "Problem: Week 5 - Hamiton Cycle\n\nDescription\nGiven an undirected graph G = (V,E). Write a program to check if G is a Hamiltonian graph.\n\nInput\nLine 1: a positive integer T (number of graphs)\nSubsequent lines are information about T graphs, each has the following format:\nLine 1: n and m (number of nodes and edges)\nLine i+1 (i = 1, 2, ..., m): u and v : two end points of the ith edge\nOutput\nIn the ith line, write 1 if the corresponding is a Hamiltonian graph, and write 0, otherwise\n\nExample\nInput\n2\n5 5\n1 2\n1 3\n2 4\n2 5\n3 5\n7 13\n1 3\n1 5\n1 7\n2 4\n2 5\n2 6\n3 4\n3 5 \n3 7\n4 6\n4 7\n5 7\n6 7\n\nOutput\n0\n1",
            "Code": "// Ph\u00f9ng M\u1ea1nh Ho\u00e0ng 20215385\n// Problem: Hamiton Cycle\n\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\n// H\u00e0m check_hamilton_cycle ki\u1ec3m tra xem \u0111\u1ed3 th\u1ecb c\u00f3 chu tr\u00ecnh Hamilton hay kh\u00f4ng\nbool check_hamilton_cycle(vector<vector<int>> Edges_85, int u_85, int bac_85[])\n{\n    int size_85 = Edges_85.size() - 1;\n    for (int i = 1; i <= size_85; i++)\n    {\n        // N\u1ebfu b\u1eadc c\u1ee7a \u0111\u1ec9nh nh\u1ecf h\u01a1n n\u1eeda s\u1ed1 \u0111\u1ec9nh th\u00ec kh\u00f4ng ph\u1ea3i chu tr\u00ecnh Hamilton\n        if (bac_85[i] < size_85 / 2)\n        {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    ios::sync_with_stdio(false); // T\u1eaft \u0111\u1ed3ng b\u1ed9 gi\u1eefa C v\u00e0 C++ streams\n    cin.tie(0);                  // Kh\u00f4ng li\u00ean k\u1ebft cin v\u1edbi cout\n\n    int T_85;\n    cin >> T_85;\n\n    for (int i = 0; i < T_85; i++)\n    {\n        int n_85, m_85;\n        cin >> n_85 >> m_85;\n\n        // Kh\u1edfi t\u1ea1o ma tr\u1eadn k\u1ec1 Edges_85\n        vector<vector<int>> Edges_85;\n        for (int i = 0; i <= n_85; i++)\n        {\n            vector<int> temp_85;\n            for (int j = 0; j <= n_85; j++)\n            {\n                temp_85.push_back(0);\n            }\n            Edges_85.push_back(temp_85);\n        }\n\n        int u_85, v_85;\n        // Kh\u1edfi t\u1ea1o m\u1ea3ng bac \u0111\u1ec3 l\u01b0u b\u1eadc c\u1ee7a c\u00e1c \u0111\u1ec9nh\n        int bac_85[10000] = {0};\n        // \u0110\u1ecdc danh s\u00e1ch c\u1ea1nh v\u00e0 c\u1eadp nh\u1eadt v\u00e0o ma tr\u1eadn k\u1ec1 v\u00e0 m\u1ea3ng bac\n        for (int i = 1; i <= m_85; i++)\n        {\n            cin >> u_85 >> v_85;\n            Edges_85[u_85][v_85] = 1;\n            Edges_85[v_85][u_85] = 1;\n            bac_85[u_85]++;\n            bac_85[v_85]++;\n        }\n\n        // Ki\u1ec3m tra xem \u0111\u1ed3 th\u1ecb c\u00f3 chu tr\u00ecnh Hamilton hay kh\u00f4ng\n        if (check_hamilton_cycle(Edges_85, u_85, bac_85))\n        {\n            cout << \"1\" << endl;\n        }\n        else\n        {\n            cout << \"0\" << endl;\n        }\n    }\n}\n"
        }
    },
    "Tuần 6": {
        "Bai1": {
            "Problem": "Problem: Week 6 - Max Flow\n\nDescription\nGiven a network G = (V, E) which is a directed weighted graph. Node s is the source and node t is the target. c(u,v) is the capacity of the arc (u,v). Find the maximum flow on G.\nInput\n\u2022Line 1: two positive integers N and M (1 <= N <= 104, 1 <= M <= 106)\n\u2022Line 2: contains 2 positive integers s and t\n\u2022Line i+2 (I = 1,. . ., M): contains two positive integers u and v which are endpoints of ith arc\n\nOutput\n  Write the value of the max-flow found\n\nExample\nInput\n7 12\n6 7\n1 7 7\n2 3 6\n2 5 6\n3 1 6\n3 7 11\n4 1 7\n4 2 4\n4 5 5\n5 1 4\n5 3 4\n6 2 8\n6 4 10\nOutput\n17\n",
            "Code": "// Ph\u00f9ng M\u1ea1nh Ho\u00e0ng 20215385\n// Problem: Max Flow\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF INT_MAX //  Gi\u00e1 tr\u1ecb l\u1edbn nh\u1ea5t cho m\u1ed9t int\n\n// H\u00e0m \u0111\u1ec3 th\u1ef1c hi\u1ec7n ph\u1ea7n BFS c\u1ee7a thu\u1eadt to\u00e1n Edmonds-Karp\nbool bfs(vector<vector<int>> &adj_85, int s_85, int t_85, vector<int> &parent_85)\n{\n    int n_85 = adj_85.size();\n    vector<bool> visited_85(n_85, false);\n    queue<int> q_85;\n    q_85.push(s_85);\n    visited_85[s_85] = true;\n    parent_85[s_85] = -1;\n\n    while (!q_85.empty())\n    {\n        int u_85 = q_85.front();\n        q_85.pop();\n\n        for (int v_85 = 0; v_85 < n_85; v_85++)\n        {\n            if (!visited_85[v_85] && adj_85[u_85][v_85] > 0)\n            {\n                q_85.push(v_85);\n                parent_85[v_85] = u_85;\n                visited_85[v_85] = true;\n            }\n        }\n    }\n\n    return visited_85[t_85];\n}\n\n// H\u00e0m \u0111\u1ec3 th\u1ef1c hi\u1ec7n thu\u1eadt to\u00e1n Edmonds-Karp\nint edmondsKarp(vector<vector<int>> &adj_85, int s_85, int t_85)\n{\n    int n_85 = adj_85.size();\n    vector<int> parent_85(n_85);\n    int max_flow_85 = 0;\n\n    // Trong khi v\u1eabn c\u00f2n \u0111\u01b0\u1eddng \u0111i t\u1eeb s \u0111\u1ebfn t\n    while (bfs(adj_85, s_85, t_85, parent_85))\n    {\n        int path_flow_85 = INF;\n        for (int v_85 = t_85; v_85 != s_85; v_85 = parent_85[v_85])\n        {\n            int u_85 = parent_85[v_85];\n            // T\u00ecm min flow tr\u00ean \u0111\u01b0\u1eddng \u0111i t\u00ecm \u0111\u01b0\u1ee3c\n            path_flow_85 = min(path_flow_85, adj_85[u_85][v_85]);\n        }\n\n        for (int v_85 = t_85; v_85 != s_85; v_85 = parent_85[v_85])\n        {\n            int u_85 = parent_85[v_85];\n            // Tr\u1eeb min flow t\u00ecm \u0111\u01b0\u1ee3c kh\u1ecfi cung thu\u1eadn v\u00e0 c\u1ed9ng v\u00e0o cung ngh\u1ecbch\n            adj_85[u_85][v_85] -= path_flow_85;\n            adj_85[v_85][u_85] += path_flow_85;\n        }\n        // C\u1eadp nh\u1eadt max flow\n        max_flow_85 += path_flow_85;\n    }\n\n    return max_flow_85;\n}\n\nint main()\n{\n    int n_85, m_85;\n    cin >> n_85 >> m_85;                                            // \u0110\u1ecdc s\u1ed1 l\u01b0\u1ee3ng \u0111\u1ec9nh v\u00e0 c\u1ea1nh\n    vector<vector<int>> adj_85(n_85 + 1, vector<int>(n_85 + 1, 0)); // Khai b\u00e1o ma tr\u1eadn k\u1ec1\n\n    int s_85, t_85;\n    cin >> s_85 >> t_85; // \u0110\u1ecdc \u0111\u1ec9nh ngu\u1ed3n v\u00e0 \u0111\u1ec9nh \u0111\u00edch\n\n    for (int i_85 = 0; i_85 < m_85; i_85++)\n    {\n        int u_85, v_85, w_85;\n        cin >> u_85 >> v_85 >> w_85; // \u0110\u1ecdc m\u1ed9t c\u1ea1nh\n        adj_85[u_85][v_85] = w_85;   // Th\u00eam c\u1ea1nh v\u00e0o ma tr\u1eadn k\u1ec1\n    }\n\n    cout << edmondsKarp(adj_85, s_85, t_85); // Ch\u1ea1y thu\u1eadt to\u00e1n Edmonds-Karp v\u00e0 in ra max flow\n}\n"
        },
        "Bai2": {
            "Problem": "Problem: Week 6 - Shortest Path between 2 nodes on a directed graph with non-negative weights\n\nDescription\nGiven a directed graph G = (V,E) in which V = {1,2,...,n) is the set of nodes. Each arc (u,v) has a non-negative weight w(u,v). Given two nodes s and t of G. Find the shortest path from s to t on G.\n\nInput\nLine 1: contains two integers n and m which are the number of nodes and the number of arcs of G (1 <= n <= 100000)\nLine i + 1(i = 1,2,...,m): contains 3 integers u, v, w in which w is the weight of arc(u,v) (0 <= w <= 100000)\nLine m+2: contains two integers s and t\n\nOutput\nWrite the weight of the shortest path found or write -1 if no path from s to t was found\n\nExample\nInput\n5 7\n2 5 87\n1 2 97\n4 5 78\n3 1 72\n1 4 19\n2 3 63\n5 1 18\n1 5\n\nOutput\n97",
            "Code": "// Ph\u00f9ng M\u1ea1nh Ho\u00e0ng 20215385\n// Problem: Week 6 - Shortest Path between 2 nodes on a directed graph with non-negative weights\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n#define INF INT_MAX // Gi\u00e1 tr\u1ecb l\u1edbn nh\u1ea5t cho m\u1ed9t int\n\n// H\u00e0m \u0111\u1ec3 th\u1ef1c hi\u1ec7n thu\u1eadt to\u00e1n Dijkstra\nvoid Dijkstra_85(int s_85, vector<int> &dist_85, vector<vector<pair<int, int>>> &adj_85)\n{\n    // Khai b\u00e1o m\u1ed9t h\u00e0ng \u0111\u1ee3i \u01b0u ti\u00ean c\u1ee7a c\u00e1c c\u1eb7p, \u0111\u01b0\u1ee3c s\u1eafp x\u1ebfp theo ph\u1ea7n t\u1eed \u0111\u1ea7u ti\u00ean c\u1ee7a c\u1eb7p\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq_85;\n    pq_85.push({0, s_85}); // \u0110\u1ea9y \u0111\u1ec9nh ngu\u1ed3n v\u00e0o h\u00e0ng \u0111\u1ee3i v\u1edbi kho\u1ea3ng c\u00e1ch 0\n    dist_85[s_85] = 0;     // Kho\u1ea3ng c\u00e1ch t\u1eeb ngu\u1ed3n \u0111\u1ebfn ch\u00ednh n\u00f3 l\u00e0 0\n\n    while (!pq_85.empty())\n    {\n        // L\u1ea5y \u0111\u1ec9nh c\u00f3 kho\u1ea3ng c\u00e1ch nh\u1ecf nh\u1ea5t v\u00e0 lo\u1ea1i b\u1ecf n\u00f3 kh\u1ecfi h\u00e0ng \u0111\u1ee3i\n        pair<int, int> front_85 = pq_85.top();\n        pq_85.pop();\n        int d_85 = front_85.first, u_85 = front_85.second;\n\n        if (d_85 == dist_85[u_85])\n            for (auto &j_85 : adj_85[u_85])\n            {\n                // N\u1ebfu kho\u1ea3ng c\u00e1ch \u0111\u1ebfn \u0111\u1ec9nh k\u1ec1 th\u00f4ng qua \u0111\u1ec9nh hi\u1ec7n t\u1ea1i nh\u1ecf h\u01a1n kho\u1ea3ng c\u00e1ch ng\u1eafn nh\u1ea5t\n                // \u0111\u00e3 bi\u1ebft tr\u01b0\u1edbc \u0111\u00f3\n                // C\u1eadp nh\u1eadt kho\u1ea3ng c\u00e1ch ng\u1eafn nh\u1ea5t v\u00e0 \u0111\u1ea9y \u0111\u1ec9nh k\u1ec1 v\u00e0o h\u00e0ng \u0111\u1ee3i\n                int v_85 = j_85.first, w_85 = j_85.second;\n                if (dist_85[u_85] + w_85 < dist_85[v_85])\n                {\n                    dist_85[v_85] = dist_85[u_85] + w_85;\n                    pq_85.push({dist_85[v_85], v_85});\n                }\n            }\n    }\n}\n\nint main()\n{\n    int n_85, m_85;\n    cin >> n_85 >> m_85;                             // \u0110\u1ecdc s\u1ed1 l\u01b0\u1ee3ng \u0111\u1ec9nh v\u00e0 c\u1ea1nh\n    vector<vector<pair<int, int>>> adj_85(n_85 + 1); // Khai b\u00e1o danh s\u00e1ch k\u1ec1\n\n    // \u0110\u1ecdc c\u00e1c c\u1ea1nh\n    for (int i_85 = 0; i_85 < m_85; i_85++)\n    {\n        int u_85, v_85, w_85;\n        cin >> u_85 >> v_85 >> w_85;          // \u0110\u1ecdc m\u1ed9t c\u1ea1nh\n        adj_85[u_85].push_back({v_85, w_85}); // Th\u00eam c\u1ea1nh v\u00e0o danh s\u00e1ch k\u1ec1\n    }\n\n    int s_85, t_85;\n    cin >> s_85 >> t_85; // \u0110\u1ecdc \u0111\u1ec9nh ngu\u1ed3n v\u00e0 \u0111\u1ec9nh \u0111\u00edch\n\n    vector<int> dist_85(n_85 + 1, INF); // Khai b\u00e1o v\u00e0 kh\u1edfi t\u1ea1o c\u00e1c kho\u1ea3ng c\u00e1ch l\u00e0 v\u00f4 c\u1ef1c\n    Dijkstra_85(s_85, dist_85, adj_85); // Ch\u1ea1y thu\u1eadt to\u00e1n Dijkstra\n\n    // In ra kho\u1ea3ng c\u00e1ch ng\u1eafn nh\u1ea5t t\u1eeb ngu\u1ed3n \u0111\u1ebfn \u0111\u00edch, ho\u1eb7c -1 n\u1ebfu kh\u00f4ng c\u00f3 \u0111\u01b0\u1eddng \u0111i\n    if (dist_85[t_85] != INF)\n        cout << dist_85[t_85];\n    else\n        cout << -1;\n}\n"
        },
        "Bai3": {
            "Problem": "Problem: Week 6 - All pair shortest paths\n\nDescription\nGiven a directed graph G = (V, E) in which V = {1, 2, ..., n} is the set of nodes, and w(u,v) is the weight (length) of the arc(u,v). Compute d(u,v) - the length of the shortest path from u to v in G, for all u,v in V.\n\nInput\nLine 1: contains 2 positive integers n and m (1 <= n,m <= 10000)\nLine i+1 (i = 1, 2, ..., m): contains 3 positive integers u, v, w in which w is the weight of the arc (u,v) (1 <= w <= 1000)\nOutput\nLine i (i = 1, 2, ..., n): wirte the ith row of the matrix d (if there is not any path from node i to node j, then d(i,j) = -1)\n\nExample\nInput\n4 9 \n1 2 9 \n1 3 7 \n1 4 2 \n2 1 1 \n2 4 5 \n3 4 6 \n3 2 2 \n4 1 5 \n4 2 8\nOutput\n0 9 7 2  \n1 0 8 3  \n3 2 0 5  \n5 8 12 0",
            "Code": "// Ph\u00f9ng M\u1ea1nh Ho\u00e0ng 20215385\n// Problem: Week 6 - All pair shortest paths\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF 1e9 // Gi\u00e1 tr\u1ecb l\u1edbn nh\u1ea5t cho m\u1ed9t int\n\n// H\u00e0m \u0111\u1ec3 th\u1ef1c hi\u1ec7n thu\u1eadt to\u00e1n Floyd-Warshall\nvoid Floyd_Warshall_85(vector<vector<int>> &dict_85, int n_85)\n{\n    // V\u00f2ng l\u1eb7p qua t\u1ea5t c\u1ea3 c\u00e1c \u0111\u1ec9nh\n    for (int k_85 = 1; k_85 <= n_85; k_85++)\n    {\n        for (int u_85 = 1; u_85 <= n_85; u_85++)\n        {\n            for (int v_85 = 1; v_85 <= n_85; v_85++)\n            {\n                // N\u1ebfu t\u1ed3n t\u1ea1i \u0111\u01b0\u1eddng \u0111i t\u1eeb u \u0111\u1ebfn k v\u00e0 t\u1eeb k \u0111\u1ebfn v\n                if (dict_85[u_85][k_85] < INF && dict_85[k_85][v_85] < INF)\n                    // C\u1eadp nh\u1eadt kho\u1ea3ng c\u00e1ch ng\u1eafn nh\u1ea5t t\u1eeb u \u0111\u1ebfn v\n                    dict_85[u_85][v_85] = min(dict_85[u_85][v_85], dict_85[u_85][k_85] + dict_85[k_85][v_85]);\n            }\n        }\n    }\n}\n\nint main()\n{\n    int n_85, m_85;\n    cin >> n_85 >> m_85; // \u0110\u1ecdc s\u1ed1 l\u01b0\u1ee3ng \u0111\u1ec9nh v\u00e0 c\u1ea1nh\n\n    // Khai b\u00e1o v\u00e0 kh\u1edfi t\u1ea1o ma tr\u1eadn kho\u1ea3ng c\u00e1ch l\u00e0 v\u00f4 c\u1ef1c\n    vector<vector<int>> dist_85(n_85 + 1, vector<int>(n_85 + 1, INF));\n\n    for (int i_85 = 1; i_85 <= n_85; i_85++)\n    {\n        dist_85[i_85][i_85] = 0; // Kho\u1ea3ng c\u00e1ch t\u1eeb m\u1ed9t \u0111\u1ec9nh \u0111\u1ebfn ch\u00ednh n\u00f3 l\u00e0 0\n    }\n\n    for (int i_85 = 0; i_85 < m_85; i_85++)\n    {\n        int u_85, v_85, w_85;\n        cin >> u_85 >> v_85 >> w_85; // \u0110\u1ecdc m\u1ed9t c\u1ea1nh\n        dist_85[u_85][v_85] = w_85;  // C\u1eadp nh\u1eadt kho\u1ea3ng c\u00e1ch t\u1eeb u \u0111\u1ebfn v\n    }\n\n    Floyd_Warshall_85(dist_85, n_85); // Ch\u1ea1y thu\u1eadt to\u00e1n Floyd-Warshall\n\n    for (int i_85 = 1; i_85 <= n_85; i_85++)\n    {\n        for (int j_85 = 1; j_85 <= n_85; j_85++)\n        {\n            // In ra kho\u1ea3ng c\u00e1ch t\u1eeb i \u0111\u1ebfn j, ho\u1eb7c -1 n\u1ebfu kh\u00f4ng c\u00f3 \u0111\u01b0\u1eddng \u0111i\n            if (dist_85[i_85][j_85] != INF)\n                cout << dist_85[i_85][j_85] << \" \";\n            else\n                cout << \"-1 \";\n        }\n        cout << \"\\n\";\n    }\n}\n"
        }
    },
    "Tuần 7": {
        "Bai1": {
            "Problem": "Problem: Week 7 - Bank Transaction\n\nDescription\nThe data about bank transactions consists of a sequence of transactions: the information of each transaction has the following format:\n                                                                    <from_account>  <to_account>   <money>   <time_point>   <atm>\nIn which:\n\u2022\t<from_account>: the account from which money is transferred (which is a string of length from 6 to 20 )\n\u2022\t<to_account>: the account which receives money in the transaction (which is a string of length from 6 to 20)\n\u2022\t<money>: amount of money transferred in the transaction (which is an integer from 1 to 10000)\n\u2022\t<time_point>: the time point at which the transaction is performed, it is a string under the format HH:MM:SS  (hour: minute: second)\n\u2022\t<atm>: the code of the ATM where the transaction is taken (a string of length from 3 to 10)\nExample: T00112233445 T001234002 2000 08:36:25 BIDV (at the ATM BIDV, account T00112233445 transfers 2000$ to account T001234002 at time point 08:36:25 (08 hour, 36 minutes, 25 seconds) \nA transaction cycle of length k starting from account a1 is defined to be a sequence of distinct account a1, a2, \u2026, ak  in which there are transactions from account a1 to a2, from a2 to a3, \u2026, from ak to a1.\nWrite a program that process the following queries: \n?number_transactions: compute the total number of transactions of the data\n?total_money_transaction: compute the total amount of money of transactions  \n?list_sorted_accounts: compute the sequence of bank accounts (including sending and receiving accounts) appearing in the transaction (sorted in an increasing (alphabetical) order)  \n?total_money_transaction_from <account>: compute the total amount of money transferred from the account <account>  \n?inspect_cycle <account> k : return 1 if there is a transaction cycle of length k, starting from <account>, and return 0, otherwise\n\nInput (stdin)\nThe input consists of 2 blocks of information: the data block and the query block\n\u2022\tThe data block consists of lines:\no\tEach line contains the information about a transaction described above\no\tThe data is terminated by a line containing #\n\u2022\tThe query block consists of lines:\no\tEach line is a query described above\no\tThe query block is terminated by a line containing #\n\nOutput (stdout)\n\u2022\tPrint to stdout (in each line) the result of each query described above\n\nExample\nInput\nT000010010 T000010020 1000 10:20:30 ATM1\nT000010010 T000010030 2000 10:02:30 ATM2\nT000010010 T000010040 1500 09:23:30 ATM1\nT000010020 T000010030 3000 08:20:31 ATM1\nT000010030 T000010010 4000 12:40:00 ATM2\nT000010040 T000010010 2000 10:30:00 ATM1\nT000010020 T000010040 3000 08:20:31 ATM1\nT000010040 T000010030 2000 11:30:00 ATM1\nT000010040 T000010030 1000 18:30:00 ATM1\n#\n?number_transactions\n?total_money_transaction\n?list_sorted_accounts\n?total_money_transaction_from T000010010\n?inspect_cycle T000010010 3\n#\nOutput\n9\n19500\nT000010010 T000010020 T000010030 T000010040\n4500\n1",
            "Code": "// Ph\u00f9ng M\u1ea1nh Ho\u00e0ng 20215385\n// Problem : Bank Transaction\n\n#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\n// \u0110\u1ecbnh ngh\u0129a c\u1ea5u tr\u00fac Transaction_85 \u0111\u1ec3 l\u01b0u tr\u1eef th\u00f4ng tin v\u1ec1 m\u1ed9t giao d\u1ecbch\ntypedef struct Transaction_85\n{\n    string from_account_85; // ID c\u1ee7a t\u00e0i kho\u1ea3n g\u1eedi\n    string to_account_85;   // ID c\u1ee7a t\u00e0i kho\u1ea3n nh\u1eadn\n    int money_85;           // S\u1ed1 ti\u1ec1n c\u1ee7a giao d\u1ecbch\n    string time_point_85;   // Th\u1eddi \u0111i\u1ec3m giao d\u1ecbch di\u1ec5n ra\n    string atm_85;          // ID c\u1ee7a m\u00e1y ATM n\u01a1i giao d\u1ecbch di\u1ec5n ra\n} Tran_85;\n\n// Kh\u1edfi t\u1ea1o c\u00e1c bi\u1ebfn to\u00e0n c\u1ee5c\nmap<string, vector<string>> adj_85; // Bi\u1ec3u di\u1ec5n \u0111\u1ed3 th\u1ecb giao d\u1ecbch d\u01b0\u1edbi d\u1ea1ng danh s\u00e1ch k\u1ec1\nmap<string, bool> visited_85;       // Bi\u1ec3u di\u1ec5n t\u1eadp h\u1ee3p c\u00e1c \u0111\u1ec9nh \u0111\u00e3 \u0111\u01b0\u1ee3c th\u0103m trong qu\u00e1 tr\u00ecnh DFS\n\n// H\u00e0m DFS \u0111\u1ec3 ki\u1ec3m tra chu tr\u00ecnh\nbool DFS_85(string account_85, string start_85, int depth_85, int k_85)\n{\n    // N\u1ebfu \u0111\u00e3 \u0111i qua \u0111\u1ee7 k b\u01b0\u1edbc v\u00e0 t\u00ecm th\u1ea5y m\u1ed9t c\u1ea1nh tr\u1edf l\u1ea1i \u0111\u1ec9nh b\u1eaft \u0111\u1ea7u\n    if (depth_85 == k_85)\n    {\n        return find(adj_85[account_85].begin(), adj_85[account_85].end(), start_85) != adj_85[account_85].end();\n    }\n    // \u0110\u00e1nh d\u1ea5u \u0111\u1ec9nh hi\u1ec7n t\u1ea1i \u0111\u00e3 \u0111\u01b0\u1ee3c th\u0103m\n    visited_85[account_85] = true;\n    // Duy\u1ec7t qua t\u1ea5t c\u1ea3 c\u00e1c \u0111\u1ec9nh k\u1ec1 v\u1edbi \u0111\u1ec9nh hi\u1ec7n t\u1ea1i\n    for (string next_account_85 : adj_85[account_85])\n    {\n        // N\u1ebfu \u0111\u1ec9nh k\u1ec1 ch\u01b0a \u0111\u01b0\u1ee3c th\u0103m v\u00e0 t\u00ecm th\u1ea5y chu tr\u00ecnh th\u00ec tr\u1ea3 v\u1ec1 true\n        if (!visited_85[next_account_85] && DFS_85(next_account_85, start_85, depth_85 + 1, k_85))\n        {\n            return true;\n        }\n    }\n    // \u0110\u00e1nh d\u1ea5u \u0111\u1ec9nh hi\u1ec7n t\u1ea1i ch\u01b0a \u0111\u01b0\u1ee3c th\u0103m (\u0111\u1ec3 t\u00ecm chu tr\u00ecnh kh\u00e1c)\n    visited_85[account_85] = false;\n    return false;\n}\n\nint main()\n{\n    ios::sync_with_stdio(false); // T\u1eaft \u0111\u1ed3ng b\u1ed9 gi\u1eefa C v\u00e0 C++ streams\n    cin.tie(0);                  // Kh\u00f4ng li\u00ean k\u1ebft cin v\u1edbi cout\n\n    vector<Tran_85> transactions_85; // Danh s\u00e1ch l\u01b0u tr\u1eef th\u00f4ng tin v\u1ec1 c\u00e1c giao d\u1ecbch\n    string s_85;\n    int total_money_transaction_85 = 0; // T\u1ed5ng s\u1ed1 ti\u1ec1n c\u1ee7a t\u1ea5t c\u1ea3 c\u00e1c giao d\u1ecbch\n    map<string, int> from_accounts_85;  // L\u01b0u tr\u1eef t\u1ed5ng s\u1ed1 ti\u1ec1n m\u00e0 m\u1ed7i t\u00e0i kho\u1ea3n \u0111\u00e3 g\u1eedi\n    set<string> accounts_85;            // L\u01b0u tr\u1eef danh s\u00e1ch c\u00e1c t\u00e0i kho\u1ea3n\n    while (true)\n    {\n        cin >> s_85;\n        if (s_85 == \"#\")\n        {\n            break;\n        }\n        Tran_85 t_85;\n        t_85.from_account_85 = s_85;\n        cin >> t_85.to_account_85 >> t_85.money_85 >> t_85.time_point_85 >> t_85.atm_85;\n        transactions_85.push_back(t_85);                         // Th\u00eam giao d\u1ecbch v\u00e0o danh s\u00e1ch\n        from_accounts_85[t_85.from_account_85] += t_85.money_85; // C\u1eadp nh\u1eadt t\u1ed5ng s\u1ed1 ti\u1ec1n m\u00e0 t\u00e0i kho\u1ea3n \u0111\u00e3 g\u1eedi\n    }\n\n    bool check_85 = false;\n    while (true)\n    {\n        cin >> s_85;\n        if (s_85 == \"#\")\n            break;\n        else if (s_85 != \"?total_money_transaction_from\" && check_85 == false)\n        {\n            check_85 = true;\n            for (auto t_85 : transactions_85)\n            {\n                total_money_transaction_85 += t_85.money_85;                // T\u00ednh t\u1ed5ng s\u1ed1 ti\u1ec1n c\u1ee7a t\u1ea5t c\u1ea3 c\u00e1c giao d\u1ecbch\n                accounts_85.insert(t_85.from_account_85);                   // Th\u00eam t\u00e0i kho\u1ea3n g\u1eedi v\u00e0o danh s\u00e1ch t\u00e0i kho\u1ea3n\n                accounts_85.insert(t_85.to_account_85);                     // Th\u00eam t\u00e0i kho\u1ea3n nh\u1eadn v\u00e0o danh s\u00e1ch t\u00e0i kho\u1ea3n\n                adj_85[t_85.from_account_85].push_back(t_85.to_account_85); // Th\u00eam c\u1ea1nh bi\u1ec3u di\u1ec5n giao d\u1ecbch v\u00e0o \u0111\u1ed3 th\u1ecb\n            }\n        }\n\n        if (s_85 == \"?total_money_transaction_from\")\n        {\n            string account_85;\n            cin >> account_85;\n            cout << from_accounts_85[account_85] << endl; // In ra t\u1ed5ng s\u1ed1 ti\u1ec1n m\u00e0 t\u00e0i kho\u1ea3n \u0111\u00e3 g\u1eedi\n        }\n        else if (s_85 == \"?number_transactions\")\n        {\n            cout << transactions_85.size() << endl; // In ra t\u1ed5ng s\u1ed1 giao d\u1ecbch\n        }\n        else if (s_85 == \"?total_money_transaction\")\n        {\n            cout << total_money_transaction_85 << endl; // In ra t\u1ed5ng s\u1ed1 ti\u1ec1n c\u1ee7a t\u1ea5t c\u1ea3 c\u00e1c giao d\u1ecbch\n        }\n        else if (s_85 == \"?list_sorted_accounts\")\n        {\n            for (const string &account_85 : accounts_85)\n            {\n                cout << account_85 << \" \"; // In ra danh s\u00e1ch c\u00e1c t\u00e0i kho\u1ea3n\n            }\n            cout << endl;\n        }\n        else if (s_85 == \"?inspect_cycle\")\n        {\n            string account_85;\n            int k_85;\n            cin >> account_85 >> k_85;\n            visited_85.clear();                                                // X\u00f3a t\u1eadp h\u1ee3p c\u00e1c \u0111\u1ec9nh \u0111\u00e3 \u0111\u01b0\u1ee3c th\u0103m\n            cout << (DFS_85(account_85, account_85, 1, k_85) ? 1 : 0) << endl; // Ki\u1ec3m tra v\u00e0 in ra k\u1ebft qu\u1ea3 ki\u1ec3m tra chu tr\u00ecnh\n        }\n    }\n    return 0;\n}\n"
        },
        "Bai2": {
            "Problem": "Problem: Week 7 - Analyze sales order of an e-commerce company\n\nDescription\nData about sales in an e-commerce company (the e-commerce company has several shops) consists a sequence of lines, each line (represents an order) has the following information:\n            <CustomerID> <ProductID> <Price> <ShopID> <TimePoint>\nin which the customer <CustomerID> buys a product <ProductID> with price <Price> at the shop <ShopID> at the time-point <TimePoint>\n<CustomerID>: string of length from 3 to 10\n<ProductID>: string of length from 3 to 10\n<Price>: a positive integer from 1 to 1000\n<ShopID>: string of length from 3 to 10\n<TimePoint>: string representing time-point with the format HH:MM:SS (for example, 09:45:20 means the time-point 9 hour 45 minutes 20 seconds)\n\n\nPerform a sequence of queries of following types:\n?total_number_orders: return the total number of orders\n?total_revenue: return the total revenue the e-commerce company gets\n?revenue_of_shop <ShopID>: return the total revenue the shop <ShopID> gets \n?total_consume_of_customer_shop <CustomerID> <ShopID>: return the total revenue the shop <ShopID> sells products to customer <CustomerID> \n?total_revenue_in_period <from_time> <to_time>: return the total revenue the e-commerce gets of the period from <from_time> to <to_time> (inclusive)\n\nInput\nThe input consists of two blocks of data:\nThe first block is the operational data, which is a sequence of lines (number of lines can be upto 100000), each line contains the information of a submission with above format \nThe first block is terminated with a line containing the character #\nThe second block is the query block, which is a sequence of lines (number of lines can be upto 100000), each line is a query described above\nThe second block is terminated with a line containing the character #\n\nOutput\nWrite in each line, the result of the corresponding query \n\nExample\nInput\nC001 P001 10 SHOP001 10:30:10\nC001 P002 30 SHOP001 12:30:10\nC003 P001 40 SHOP002 10:15:20\nC001 P001 80 SHOP002 08:40:10\nC002 P001 130 SHOP001 10:30:10\nC002 P001 160 SHOP003 11:30:20\n#\n?total_number_orders\n?total_revenue\n?revenue_of_shop SHOP001\n?total_consume_of_customer_shop C001 SHOP001 \n?total_revenue_in_period 10:00:00 18:40:45\n#\n\n\nOutput \n6\n450\n170\n40\n370",
            "Code": "// Ph\u00f9ng Manh Ho\u00e0ng 20215385\n// Problem: Analyze sales order of an e-commerce company\n\n#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\n// \u0110\u1ecbnh ngh\u0129a c\u1ea5u tr\u00fac giao d\u1ecbch\ntypedef struct Transaction_85\n{\n    string customer_id_85; // ID c\u1ee7a kh\u00e1ch h\u00e0ng\n    string product_id_85;  // ID c\u1ee7a s\u1ea3n ph\u1ea9m\n    int price_85;          // Gi\u00e1 c\u1ee7a s\u1ea3n ph\u1ea9m\n    string shop_id_85;     // ID c\u1ee7a c\u1eeda h\u00e0ng\n    string time_point_85;  // Th\u1eddi \u0111i\u1ec3m giao d\u1ecbch\n} Order_85;\n\n// H\u00e0m so s\u00e1nh \u0111\u1ec3 s\u1eafp x\u1ebfp c\u00e1c giao d\u1ecbch theo th\u1eddi gian\nbool compareByTime_85(const Order_85 &a, const Order_85 &b)\n{\n    return a.time_point_85 < b.time_point_85;\n}\n\nint main()\n{\n    ios::sync_with_stdio(false); // T\u1eaft \u0111\u1ed3ng b\u1ed9 gi\u1eefa C v\u00e0 C++ streams\n    cin.tie(0);                  // Kh\u00f4ng li\u00ean k\u1ebft cin v\u1edbi cout\n\n    vector<Order_85> orders_85; // Danh s\u00e1ch c\u00e1c giao d\u1ecbch\n    string s_85;\n    map<string, int> shop_revenues_85;          // Doanh thu c\u1ee7a m\u1ed7i c\u1eeda h\u00e0ng\n    map<string, int> customer_shop_revenues_85; // Doanh thu t\u1eeb m\u1ed7i kh\u00e1ch h\u00e0ng cho m\u1ed7i c\u1eeda h\u00e0ng\n    map<string, int> accumulated_revenue_85;    // Doanh thu t\u00edch l\u0169y theo th\u1eddi gian\n    while (true)\n    {\n        cin >> s_85;\n        if (s_85 == \"#\")\n        {\n            break;\n        }\n        Order_85 order_85;\n        order_85.customer_id_85 = s_85;\n        cin >> order_85.product_id_85 >> order_85.price_85 >> order_85.shop_id_85 >> order_85.time_point_85;\n        orders_85.push_back(order_85); // Th\u00eam giao d\u1ecbch v\u00e0o danh s\u00e1ch\n    }\n\n    int total_revenue_85 = 0; // T\u1ed5ng doanh thu\n\n    bool check_total_revenue_85 = false;\n    bool check_revenue_of_shop_85 = false;\n    bool check_total_consume_of_customer_shop_85 = false;\n    bool check_total_revenue_in_period_85 = false;\n\n    while (true)\n    {\n        cin >> s_85;\n        if (s_85 == \"#\")\n            break;\n        else if (s_85 == \"?total_number_orders\")\n        {\n            cout << orders_85.size() << endl; // In ra t\u1ed5ng s\u1ed1 giao d\u1ecbch\n        }\n        else if (s_85 == \"?total_revenue\")\n        {\n            if (check_total_revenue_85 == false)\n            {\n                check_total_revenue_85 = true;\n                sort(orders_85.begin(), orders_85.end(), compareByTime_85); // S\u1eafp x\u1ebfp c\u00e1c giao d\u1ecbch theo th\u1eddi gian\n                for (auto &order_85 : orders_85)\n                {\n                    total_revenue_85 += order_85.price_85;                             // T\u00ednh t\u1ed5ng doanh thu\n                    accumulated_revenue_85[order_85.time_point_85] = total_revenue_85; // C\u1eadp nh\u1eadt doanh thu t\u00edch l\u0169y\n                }\n            }\n            cout << total_revenue_85 << endl; // In ra t\u1ed5ng doanh thu\n        }\n        else if (s_85 == \"?revenue_of_shop\")\n        {\n            if (check_revenue_of_shop_85 == false)\n            {\n                check_revenue_of_shop_85 = true;\n                for (auto &order_85 : orders_85)\n                {\n                    shop_revenues_85[order_85.shop_id_85] += order_85.price_85; // T\u00ednh doanh thu c\u1ee7a m\u1ed7i c\u1eeda h\u00e0ng\n                }\n            }\n            string shop_id_85;\n            cin >> shop_id_85;\n            cout << shop_revenues_85[shop_id_85] << endl; // In ra doanh thu c\u1ee7a c\u1eeda h\u00e0ng\n        }\n        else if (s_85 == \"?total_consume_of_customer_shop\")\n        {\n            if (check_total_consume_of_customer_shop_85 == false)\n            {\n                check_total_consume_of_customer_shop_85 = true;\n                for (auto &order_85 : orders_85)\n                {\n                    customer_shop_revenues_85[order_85.customer_id_85 + order_85.shop_id_85] += order_85.price_85; // T\u00ednh doanh thu t\u1eeb m\u1ed7i kh\u00e1ch h\u00e0ng cho m\u1ed7i c\u1eeda h\u00e0ng\n                }\n            }\n            string customer_id_85, shop_id_85;\n            cin >> customer_id_85 >> shop_id_85;\n            cout << customer_shop_revenues_85[customer_id_85 + shop_id_85] << endl; // In ra doanh thu t\u1eeb kh\u00e1ch h\u00e0ng cho c\u1eeda h\u00e0ng\n        }\n        else if (s_85 == \"?total_revenue_in_period\")\n        {\n            if (check_total_revenue_in_period_85 == false)\n            {\n                check_total_revenue_in_period_85 = true;\n                sort(orders_85.begin(), orders_85.end(), compareByTime_85); // S\u1eafp x\u1ebfp c\u00e1c giao d\u1ecbch theo th\u1eddi gian\n                for (auto &order_85 : orders_85)\n                {\n                    total_revenue_85 += order_85.price_85;                             // T\u00ednh t\u1ed5ng doanh thu\n                    accumulated_revenue_85[order_85.time_point_85] = total_revenue_85; // C\u1eadp nh\u1eadt doanh thu t\u00edch l\u0169y\n                }\n            }\n            string from_time_85, to_time_85;\n            cin >> from_time_85 >> to_time_85;\n            auto from_it_85 = accumulated_revenue_85.lower_bound(from_time_85);\n            auto to_it_85 = accumulated_revenue_85.upper_bound(to_time_85);\n            int from_revenue_85 = (from_it_85 == accumulated_revenue_85.begin()) ? 0 : prev(from_it_85)->second;\n            int to_revenue_85 = (to_it_85 == accumulated_revenue_85.begin()) ? 0 : prev(to_it_85)->second;\n            int revenue_85 = to_revenue_85 - from_revenue_85; // T\u00ednh doanh thu trong kho\u1ea3ng th\u1eddi gian\n            cout << revenue_85 << endl;                       // In ra doanh thu trong kho\u1ea3ng th\u1eddi gian\n        }\n    }\n    return 0;\n}\n"
        }
    },
    "Tuần 8": {
        "Bài 1": {
            "Problem": "Problem: Week 8 - Analyze Code Submission of a Programming Contest\n\nDescription\nData about submission of a programming contest consists a sequence of lines, each line has the following information:\n                                                      <UserID> <ProblemID> <TimePoint> <Status> <Point>\nin which the user <UserID> submits his/her code to solve the problem <ProblemID> at time-point <TimePoint>, and gets status <Status> and point <Point>\n<UserID>: string of length from 3 to 10\n<ProblemID>: string under the format Pxy where x, y are digits 0,1,...,9 (for example P03, P10)\n<TimePoint>: string representing time-point with the format HH:MM:SS (for example, 09:45:20 means the time-point 9 hour 45 minutes 20 seconds)\n<Status>: string with two cases (ERR, OK)\n<Point>: integer from {0, 1, 2, ..., 10}\n\nA user can submit the code for solving each problem several time. The point that the user gets for a problem is the maximal point among the submissions for that problem.\n\nPerform a sequence of queries of following types:\n?total_number_submissions: return the number of submissions of the contest\n?number_error_submision: return the number of submissions having status ERR \n?number_error_submision_of_user <UserID>: return the number of submission having status ERR of user <UserID> \n?total_point_of_user <UserID>: return the total point of user <UserID> \n?number_submission_period <from_time_point> <to_time_point>: return the number of submissions in the period from <from_time_point> to <to_time_point> (inclusive)\n\nInput\nThe input consists of two blocks of data:\nThe first block is the operational data, which is a sequence of lines (number of lines can be up to 100000), each line contains the information of a submission with above format .The first block is terminated with a line containing the character #\nThe second block is the query block, which is a sequence of lines (number of lines can be up to 100000), each line is a query described above. The second block is terminated with a line containing the character #\n\nOutput\nWrite in each line, the result of the corresponding query \n\nExample\nInput\nU001 P01 10:30:20 ERR 0\nU001 P01 10:35:20 OK 10\nU001 P02 10:40:20 ERR 0\nU001 P02 10:55:20 OK 7\nU002 P01 10:40:20 ERR 0\nU001 P01 11:35:20 OK 8\nU002 P02 10:40:20 OK 10\n#\n?total_number_submissions\n?number_error_submision\n?number_error_submision_of_user U002 \n?total_point_of_user U001 \n?number_submission_period 10:00:00 11:30:45\n#\n\n\nOutput \n7\n3\n1\n17\n6\n",
            "Code": "// Ph\u00f9ng M\u1ea1nh Ho\u00e0ng 20215385\n// Problem: Analyze Code Submission of a Programming Contest\n\n#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\n// \u0110\u1ecbnh ngh\u0129a c\u1ea5u tr\u00fac Submission_85\nstruct Submission_85\n{\n    string user_id_85;    // ID c\u1ee7a ng\u01b0\u1eddi d\u00f9ng\n    string problem_id_85; // ID c\u1ee7a b\u00e0i to\u00e1n\n    string time_point_85; // Th\u1eddi \u0111i\u1ec3m n\u1ed9p b\u00e0i\n    string status_85;     // Tr\u1ea1ng th\u00e1i c\u1ee7a b\u00e0i n\u1ed9p\n    int point_85;         // \u0110i\u1ec3m s\u1ed1 c\u1ee7a b\u00e0i n\u1ed9p\n};\n\n// H\u00e0m so s\u00e1nh th\u1eddi gian gi\u1eefa m\u1ed9t Submission_85 v\u00e0 m\u1ed9t chu\u1ed7i th\u1eddi gian\nbool compare_time_85(const Submission_85 &sub_85, const string &time_85)\n{\n    return sub_85.time_point_85 < time_85;\n}\n\n// H\u00e0m so s\u00e1nh hai Submission_85 d\u1ef1a tr\u00ean th\u1eddi gian\nbool compare_submissions_85(const Submission_85 &a_85, const Submission_85 &b_85)\n{\n    return a_85.time_point_85 < b_85.time_point_85;\n}\n\nint main()\n{\n    ios::sync_with_stdio(false); // T\u1eaft \u0111\u1ed3ng b\u1ed9 gi\u1eefa C v\u00e0 C++ streams\n    cin.tie(0);                  // Kh\u00f4ng li\u00ean k\u1ebft cin v\u1edbi cout\n\n    // Kh\u1edfi t\u1ea1o vector \u0111\u1ec3 l\u01b0u tr\u1eef c\u00e1c submissions_85\n    vector<Submission_85> submissions_85;\n    // Kh\u1edfi t\u1ea1o map \u0111\u1ec3 l\u01b0u tr\u1eef \u0111i\u1ec3m s\u1ed1 c\u1ee7a ng\u01b0\u1eddi d\u00f9ng\n    map<string, map<string, int>> user_points_85;\n    string s_85;\n\n    // \u0110\u1ecdc d\u1eef li\u1ec7u t\u1eeb \u0111\u1ea7u v\u00e0o\n    while (true)\n    {\n        cin >> s_85;\n        if (s_85 == \"#\")\n            break;\n\n        // Kh\u1edfi t\u1ea1o m\u1ed9t submission m\u1edbi v\u00e0 th\u00eam v\u00e0o danh s\u00e1ch submissions\n        Submission_85 sub_85;\n        sub_85.user_id_85 = s_85;\n        cin >> sub_85.problem_id_85 >> sub_85.time_point_85 >> sub_85.status_85 >> sub_85.point_85;\n        submissions_85.push_back(sub_85);\n    }\n\n    bool check_total_point_of_user_85 = false;\n    bool check_number_submission_period_85 = false;\n\n    // X\u1eed l\u00fd c\u00e1c c\u00e2u truy v\u1ea5n\n    while (true)\n    {\n        cin >> s_85;\n        if (s_85 == \"#\")\n            break;\n\n        if (s_85 == \"?total_point_of_user\" && !check_total_point_of_user_85)\n        {\n            for (auto sub_85 : submissions_85)\n            {\n                if (sub_85.status_85 == \"OK\")\n                {\n                    user_points_85[sub_85.user_id_85][sub_85.problem_id_85] = max(user_points_85[sub_85.user_id_85][sub_85.problem_id_85], sub_85.point_85);\n                }\n            }\n            check_total_point_of_user_85 = true;\n        }\n\n        if (s_85 == \"?number_submission_period\" && !check_number_submission_period_85)\n        {\n            sort(submissions_85.begin(), submissions_85.end(), compare_submissions_85);\n            check_number_submission_period_85 = true;\n        }\n\n        // X\u1eed l\u00fd c\u00e2u truy v\u1ea5n ?total_number_submissions\n        if (s_85 == \"?total_number_submissions\")\n        {\n            cout << submissions_85.size() << endl;\n        }\n\n        // X\u1eed l\u00fd c\u00e2u truy v\u1ea5n ?number_error_submision\n        if (s_85 == \"?number_error_submision\")\n        {\n            int count_85 = 0;\n            for (auto sub_85 : submissions_85)\n            {\n                if (sub_85.status_85 == \"ERR\")\n                    count_85++;\n            }\n            cout << count_85 << endl;\n        }\n        // X\u1eed l\u00fd c\u00e2u truy v\u1ea5n ?number_error_submision_of_user\n        if (s_85 == \"?number_error_submision_of_user\")\n        {\n            string user_id_85;\n            cin >> user_id_85;\n            int count_85 = 0;\n            for (auto sub_85 : submissions_85)\n            {\n                if (sub_85.user_id_85 == user_id_85 && sub_85.status_85 == \"ERR\")\n                    count_85++;\n            }\n            cout << count_85 << endl;\n        }\n\n        // X\u1eed l\u00fd c\u00e2u truy v\u1ea5n ?total_point_of_user\n        if (s_85 == \"?total_point_of_user\")\n        {\n            string user_id_85;\n            cin >> user_id_85;\n            int total_points_85 = 0;\n            for (auto p_85 : user_points_85[user_id_85])\n            {\n                total_points_85 += p_85.second;\n            }\n            cout << total_points_85 << endl;\n        }\n\n        // X\u1eed l\u00fd c\u00e2u truy v\u1ea5n ?number_submission_period\n        if (s_85 == \"?number_submission_period\")\n        {\n            string from_time_85, to_time_85;\n            cin >> from_time_85 >> to_time_85;\n            auto start_85 = lower_bound(submissions_85.begin(), submissions_85.end(), Submission_85{.time_point_85 = from_time_85}, compare_submissions_85);\n            auto end_85 = upper_bound(submissions_85.begin(), submissions_85.end(), Submission_85{.time_point_85 = to_time_85}, compare_submissions_85);\n            cout << distance(start_85, end_85) << endl;\n        }\n    }\n}"
        },
        "Bài 2": {
            "Problem": "Problem: Week 8 - Citizen Data Analysis\n\nDescription\nCITIZEN\nGiven a DataBase about citizen, perform queries over this DataBase.\nInput\nThe input consists of two blocks: the first block is the DataBase and the second block is the list of queries. Two blocks are separated by a line containing a character *.\n1. The first block (DataBase about citizen) consists of lines (number of lines can be upto 100000), each line is the information about a person and is under the format:\n                                   <code>  <dat_of_birth>  <fathher_code>   <mother_code>  <is_alive>  <region_code>\nin which:\n <code>: the code of the person which is a string of length 7\n <date_of_birth>: the date of birth of the person and has the format YYYY-MM-DD (for example 1980-02-23), <date_of_birth> is before 3000-12-31\n <fathher_code> and <mother_code> is the code of father and mother: they are also strings of length 7. If the code is 0000000, then the current person does not has information about his father or mother\n <is_alive>: a character with two values: \u2018Y\u2019 means that the person is still alive, and \u2018N\u2019 means tat the current person is died.\n <region_code>: the code of the region where the person lives\n\n2. The second block is the list of queries (number of queries can be upto 100000) over the DataBase which consists of following commands:\n NUMBER_PEOPLE: return the number of people (number of lines of the DataBase)\n NUMBER_PEOPLE_BORN_AT <date>: return the number of people having date-of-birth is equal to <date>\n MOST_ALIVE_ANCESTOR <code>: find the most ancestor (farthest in term of generation distance) of the given person <code>. Return the generation distance between the ancestor found and the given person\n NUMBER_PEOPLE_BORN_BETWEEN <from_date> <to_date>: compute the number of people having date-of-birth between <from_date> and <to_date> (<from_date> and <to_date> are under the form YYYY-MM-DD, <to_date> is before 3000-12-31)\n MAX_UNRELATED_PEOPLE: find a subset of people in which two any people of the subset do not have father/mother-children and the size of the subset is maximal. Return the size of the subset found.\nThe second block is terminated by a line containing ***.\nOutput\n Each line presents the result of the corresponding query (described above)\n\nExample\nInput\n0000001 1920-08-10 0000000 0000000 Y 00002\n0000002 1920-11-03 0000000 0000000 Y 00003\n0000003 1948-02-13 0000001 0000002 Y 00005\n0000004 1946-01-16 0000001 0000002 Y 00005\n0000005 1920-11-27 0000000 0000000 Y 00005\n0000006 1920-02-29 0000000 0000000 Y 00004\n0000007 1948-07-18 0000005 0000006 Y 00005\n0000008 1948-07-18 0000005 0000006 Y 00002\n0000009 1920-03-09 0000000 0000000 Y 00005\n0000010 1920-10-16 0000000 0000000 Y 00005\n*\nNUMBER_PEOPLE\nNUMBER_PEOPLE_BORN_AT 1919-12-10\nNUMBER_PEOPLE_BORN_AT 1948-07-18\nMAX_UNRELATED_PEOPLE\nMOST_ALIVE_ANCESTOR 0000008\nMOST_ALIVE_ANCESTOR 0000001\nNUMBER_PEOPLE_BORN_BETWEEN 1900-12-19 1928-11-16\nNUMBER_PEOPLE_BORN_BETWEEN 1944-08-13 1977-12-15\nNUMBER_PEOPLE_BORN_BETWEEN 1987-01-24 1988-06-03\n***\nOutput\n10\n0\n2\n6\n1\n0\n6\n4\n0",
            "Code": "// Ph\u00f9ng M\u1ea1nh Ho\u00e0ng 20215385\n// Problem: Week 8 - Citizen Data Analysis\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass CitizenData_85\n{\nprivate:\n    // \u0110\u1ecbnh ngh\u0129a m\u1ed9t c\u1ea5u tr\u00fac cho Citizen\n    struct Citizen_85\n    {\n        string Code_85, Date_of_birth_85, Father_code_85, Mother_code_85, region_code_85;\n        bool is_alive_85;\n        Citizen_85(string a, string b, string c, string d, bool e, string f) : Code_85(a), Date_of_birth_85(b), Father_code_85(c), Mother_code_85(d), is_alive_85(e), region_code_85(f) {}\n    };\n    vector<Citizen_85> lst_85;             // Danh s\u00e1ch c\u00e1c c\u00f4ng d\u00e2n\n    vector<int> cnt_85;                    // S\u1ed1 l\u01b0\u1ee3ng c\u00f4ng d\u00e2n\n    unordered_map<string, int> id_85;      // B\u1ea3n \u0111\u1ed3 ID c\u00f4ng d\u00e2n\n    int n_85 = 0;                          // S\u1ed1 l\u01b0\u1ee3ng c\u00f4ng d\u00e2n\n    vector<vector<int>> adj_85, parent_85; // Danh s\u00e1ch k\u1ec1 v\u00e0 danh s\u00e1ch cha\n    vector<int> color_85;                  // M\u00e0u c\u1ee7a c\u00e1c n\u00fat\n    int sz_85, d_85, subset_size_85;       // K\u00edch th\u01b0\u1edbc, b\u1eadc, v\u00e0 k\u00edch th\u01b0\u1edbc t\u1eadp con\n    vector<int> dep_85;                    // \u0110\u1ed9 s\u00e2u c\u1ee7a c\u00e1c n\u00fat\n    vector<bool> have_parent_85;           // Ki\u1ec3m tra n\u1ebfu n\u00fat c\u00f3 cha\n    vector<int> f_85;                      // Vector cho quy ho\u1ea1ch \u0111\u1ed9ng\n\n    // H\u00e0m chuy\u1ec3n \u0111\u1ed5i ng\u00e0y th\u00e0nh s\u1ed1 nguy\u00ean\n    int toInt_85(string _date_85)\n    {\n        int res_85 = 0;\n        for (int i = 0; i < _date_85.size(); i++)\n            if (_date_85[i] != '-')\n                res_85 = res_85 * 10 + _date_85[i] - '0';\n        return res_85;\n    }\n    // H\u00e0m t\u00ecm ki\u1ebfm theo chi\u1ec1u s\u00e2u\n    void DFS_85(int u_85, bool c_85)\n    {\n        sz_85++;\n        d_85 += c_85;\n        color_85[u_85] = c_85;\n        for (int v_85 : adj_85[u_85])\n            if (color_85[v_85] == -1)\n                DFS_85(v_85, c_85 ^ 1);\n    }\n    // H\u00e0m quy ho\u1ea1ch \u0111\u1ed9ng\n    int dp_85(int v_85)\n    {\n        if (!have_parent_85[v_85])\n            return 0;\n        if (f_85[v_85])\n            return f_85[v_85];\n        for (int u_85 : parent_85[v_85])\n            f_85[v_85] = max(f_85[v_85], dp_85(u_85) + 1);\n        return f_85[v_85];\n    }\n\npublic:\n    // H\u00e0m th\u00eam m\u1ed9t c\u00f4ng d\u00e2n\n    void add_85(string a, string b, string c, string d, string e, string f)\n    {\n        lst_85.push_back(Citizen_85(a, b, c, d, e == \"Y\", f));\n    }\n    // H\u00e0m chu\u1ea9n h\u00f3a d\u1eef li\u1ec7u\n    void standardize_85()\n    {\n        cnt_85.assign(30010000, 0);\n        adj_85.resize(100001);\n        parent_85.resize(100001);\n        have_parent_85.assign(100001, false);\n        for (auto [_code_85, _date_of_birth_85, _father_code_85, _mother_code_85, _region_code_85, _is_alive_85] : lst_85)\n        {\n            cnt_85[toInt_85(_date_of_birth_85)]++;\n            if (toInt_85(_date_of_birth_85) >= 30010000)\n            {\n                cout << \"ngu\";\n                exit(0);\n            }\n            if (!id_85[_code_85])\n                id_85[_code_85] = ++n_85;\n            if (!id_85[_father_code_85])\n                id_85[_father_code_85] = ++n_85;\n            if (!id_85[_mother_code_85])\n                id_85[_mother_code_85] = ++n_85;\n            if (_father_code_85 != \"0000000\")\n            {\n                parent_85[id_85[_code_85]].push_back(id_85[_father_code_85]);\n                adj_85[id_85[_code_85]].push_back(id_85[_father_code_85]);\n                adj_85[id_85[_father_code_85]].push_back(id_85[_code_85]);\n            }\n            if (_mother_code_85 != \"0000000\")\n            {\n                parent_85[id_85[_code_85]].push_back(id_85[_mother_code_85]);\n                adj_85[id_85[_code_85]].push_back(id_85[_mother_code_85]);\n                adj_85[id_85[_mother_code_85]].push_back(id_85[_code_85]);\n            }\n            have_parent_85[id_85[_code_85]] = (_father_code_85 != \"0000000\" || _mother_code_85 != \"0000000\");\n        }\n\n        for (int i = 1; i < 30010000; i++)\n            cnt_85[i] += cnt_85[i - 1];\n\n        color_85.assign(100001, -1);\n        for (int u_85 = 1; u_85 <= n_85; u_85++)\n            if (color_85[u_85] == -1)\n            {\n                sz_85 = d_85 = 0;\n                DFS_85(u_85, 0);\n                subset_size_85 += max(d_85, sz_85 - d_85);\n            }\n\n        f_85.assign(100001, 0);\n    }\n\n    // H\u00e0m l\u1ea5y s\u1ed1 l\u01b0\u1ee3ng ng\u01b0\u1eddi\n    int number_people_85()\n    {\n        return lst_85.size();\n    }\n    // H\u00e0m l\u1ea5y s\u1ed1 l\u01b0\u1ee3ng ng\u01b0\u1eddi sinh v\u00e0o m\u1ed9t ng\u00e0y c\u1ee5 th\u1ec3\n    int number_of_people_born_at_85(string _date_85)\n    {\n        return cnt_85[toInt_85(_date_85)] - cnt_85[toInt_85(_date_85) - 1];\n    }\n    // H\u00e0m l\u1ea5y t\u1ed5 ti\u00ean s\u1ed1ng l\u00e2u nh\u1ea5t\n    int most_alive_ancestor_85(string _code_85)\n    {\n        return dp_85(id_85[_code_85]);\n    }\n    // H\u00e0m l\u1ea5y s\u1ed1 l\u01b0\u1ee3ng ng\u01b0\u1eddi sinh gi\u1eefa hai ng\u00e0y\n    int number_of_people_born_between_85(string from_date_85, string to_date_85)\n    {\n        return cnt_85[toInt_85(to_date_85)] - cnt_85[toInt_85(from_date_85) - 1];\n    }\n    // H\u00e0m l\u1ea5y s\u1ed1 l\u01b0\u1ee3ng ng\u01b0\u1eddi kh\u00f4ng li\u00ean quan t\u1ed1i \u0111a\n    int max_unrelated_people_85()\n    {\n        return subset_size_85 - 1;\n    }\n};\n\nCitizenData_85 S_85;\n\nsigned main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n\n    string _code_85, _date_of_birth_85, _father_code_85, _mother_code_85, _is_alive_85, _region_code_85;\n    // \u0110\u1ecdc d\u1eef li\u1ec7u t\u1eebng c\u00f4ng d\u00e2n\n    while (cin >> _code_85)\n    {\n        if (_code_85 == \"*\")\n            break;\n        cin >> _date_of_birth_85 >> _father_code_85 >> _mother_code_85 >> _is_alive_85 >> _region_code_85;\n        S_85.add_85(_code_85, _date_of_birth_85, _father_code_85, _mother_code_85, _is_alive_85, _region_code_85);\n    }\n\n    // Chu\u1ea9n h\u00f3a d\u1eef li\u1ec7u\n    S_85.standardize_85();\n\n    string query_85;\n    // X\u1eed l\u00fd c\u00e1c truy v\u1ea5n\n    while (cin >> query_85)\n    {\n        if (query_85 == \"*\")\n            break;\n        if (query_85 == \"NUMBER_PEOPLE\")\n            cout << S_85.number_people_85() << endl;\n        else if (query_85 == \"NUMBER_PEOPLE_BORN_AT\")\n        {\n            string _date_85;\n            cin >> _date_85;\n            cout << S_85.number_of_people_born_at_85(_date_85) << endl;\n        }\n        else if (query_85 == \"MOST_ALIVE_ANCESTOR\")\n        {\n            string _code_85;\n            cin >> _code_85;\n            cout << S_85.most_alive_ancestor_85(_code_85) << endl;\n        }\n        else if (query_85 == \"NUMBER_PEOPLE_BORN_BETWEEN\")\n        {\n            string _from_date_85, _to_date_85;\n            cin >> _from_date_85 >> _to_date_85;\n            cout << S_85.number_of_people_born_between_85(_from_date_85, _to_date_85) << endl;\n        }\n        else if (query_85 == \"MAX_UNRELATED_PEOPLE\")\n            cout << S_85.max_unrelated_people_85() << endl;\n    }\n}\n"
        }
    }
}