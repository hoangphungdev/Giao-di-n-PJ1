{
    "Tuần 1": {
        "Bài 1": "// Phung Manh Hoang 20215385\n// Problem: Sum Array\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n    int n_85;\n    int a_85[100000];\n    int sum_85 = 0;\n    cin >> n_85; // Nhap n\n\n    for (int i = 0; i < n_85; i++)\n    {\n        cin >> a_85[i];\n        sum_85 += a_85[i]; // Tinh tong tung phan tu cua mang\n    }\n    cout << sum_85; // In tong phan tu cua mang\n}",
        "Bài 2": "// Phung Manh Hoang 20215385\n// Problem: List sequence of integer having 3 digits divisible by n\n\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n    int n_85;\n    cin >> n_85; // Nhap n\n\n    //  Tim so nguyen co 3 chu so chia het cho n\n    for (int i = 1; i < 1000; i++)\n    {\n        int x_85 = n_85 * i;\n        if (x_85 > 999)\n            break;\n        if (x_85 >= 100 && x_85 <= 999)\n        {\n            cout << x_85 << \" \"; // In so nguyen co 3 chu so chia het cho n\n        }\n    }\n}\n",
        "Bài 3": "// Phung Manh Hoang 20215385\n// Problem: So s\u00e1nh ch\u00eanh l\u1ec7ch gi\u00e1 \u0111i\u1ec7n theo \u0111\u1ec1 xu\u1ea5t m\u1edbi c\u1ee7a EVN\n\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n    int n_85;\n    cin >> n_85; // Nhap n\n    double oldPrice_85 = 0;\n    double newPrice_85 = 0;\n\n    // Tinh gia dien cu\n    if (n_85 >= 0 && n_85 <= 50)\n    {\n        oldPrice_85 = n_85 * 1.728 * 1100;\n    }\n    else if (n_85 <= 100)\n    {\n        oldPrice_85 = (86.4 + (n_85 - 50) * 1.786) * 1100;\n    }\n    else if (n_85 <= 200)\n    {\n        oldPrice_85 = (175.7 + (n_85 - 100) * 2.074) * 1100;\n    }\n    else if (n_85 <= 300)\n    {\n        oldPrice_85 = (383.1 + (n_85 - 200) * 2.612) * 1100;\n    }\n    else if (n_85 <= 400)\n    {\n        oldPrice_85 = (644.3 + (n_85 - 300) * 2.919) * 1100;\n    }\n    else\n    {\n        oldPrice_85 = (936.2 + (n_85 - 400) * 3.015) * 1100;\n    }\n\n    // Tinh gia dien moi\n    if (n_85 >= 0 && n_85 <= 100)\n    {\n        newPrice_85 = n_85 * 1.728 * 1100;\n    }\n    else if (n_85 <= 200)\n    {\n        newPrice_85 = (172.8 + (n_85 - 100) * 2.074) * 1100;\n    }\n    else if (n_85 <= 400)\n    {\n        newPrice_85 = (380.2 + (n_85 - 200) * 2.612) * 1100;\n    }\n    else if (n_85 <= 700)\n    {\n        newPrice_85 = (902.6 + (n_85 - 400) * 3.111) * 1100;\n    }\n    else\n    {\n        newPrice_85 = (1835.9 + (n_85 - 700) * 3.457) * 1100;\n    }\n\n    printf(\"%.2f\\n\", newPrice_85 - oldPrice_85); // In ket qua\n}\n",
        "Bài 4": "// Phung Manh Hoang 20215385\n// Problem: Convert a TEXT to Upper-Case\n\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n    string s_85;\n    while (getline(cin, s_85))\n    {\n        // Convert a TEXT to Upper-Case\n        for (int i = 0; s_85[i] != '\\0'; i++)\n        {\n            if (s_85[i] >= 'a' && s_85[i] <= 'z')\n            {\n                s_85[i] = s_85[i] - 32;\n            }\n        }\n        cout << s_85 << endl; // In ket qua\n    }\n}",
        "Bài 5": "// Phung Manh Hoang 20215385\n// Problem: Extract Year, Month, Date from a String YYYY-MM-DD\n\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n    string s_85;\n    getline(cin, s_85); // Nhap xau\n\n    // Kiem tra xau co dung dinh dang hay khong\n    if (s_85.size() != 10 || s_85[4] != '-' || s_85[7] != '-')\n    {\n        cout << \"INCORRECT\";\n        return 0;\n    }\n    int thang_85 = (s_85[5] - 48) * 10 + (s_85[6] - 48);\n    int ngay_85 = (s_85[8] - 48) * 10 + (s_85[9] - 48);\n\n    // Kiem tra xau co dung dinh dang hay khong\n    if (thang_85 < 1 || thang_85 > 12 || ngay_85 < 1 || ngay_85 > 31)\n    {\n        cout << \"INCORRECT\";\n        return 0;\n    }\n\n    // In ket qua\n    for (int i = 0; i < 10; i++)\n    {\n        if (s_85[i] == '-')\n            cout << ' ';\n        else if (i > 4 && s_85[i] == '0')\n            continue;\n        else\n            cout << s_85[i];\n    }\n}",
        "Bài 6": "// Phung Manh Hoang 20215385\n// Problem: List all numbers from 1 to n and its squares\n\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n    int n_85;\n    cin >> n_85; // Nhap n\n    // Tinh binh phuong\n    for (int i = 1; i <= n_85; i++)\n    {\n        cout << i << \" \" << i * i << endl; // In ket qua\n    }\n}",
        "Bài 7": "// Phung Manh Hoang 20215385\n// Problem: Count odd and even number from a sequence\n\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n    int n_85;\n    int arr_85[100000];\n    int odd_85 = 0;\n    int even_85 = 0;\n    cin >> n_85; // Nhap n\n\n    // Dem so chan va so le trong mang\n    for (int i = 0; i < n_85; i++)\n    {\n        cin >> arr_85[i];\n        if (arr_85[i] % 2 == 1)\n            odd_85++;\n        else\n            even_85++;\n    }\n    cout << odd_85 << \" \" << even_85; // In ket qua\n}",
        "Bài 8": "// Phung Manh Hoang 20215385\n// Problem: Add Subtract Multiplication Division of A and B\n\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n    int a_85, b_85;\n    cin >> a_85 >> b_85; // Nhap a va b\n\n    cout << a_85 + b_85 << \" \" << a_85 - b_85 << \" \" << a_85 * b_85 << \" \" << a_85 / b_85; // In ket qua\n}",
        "Bài 9": "// Phung Manh Hoang 20215385\n// Problem: Convert hh:mm:ss to seconds\n\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n    string s;\n    getline(cin, s); // Nhap xau\n\n    // Kiem tra xem xau co dung dinh dang khong\n    if (s.size() != 8 || s[2] != ':' || s[5] != ':')\n    {\n        cout << \"INCORRECT\";\n        return 0;\n    }\n\n    int gio_85 = (s[0] - 48) * 10 + (s[1] - 48);\n    int phut_85 = (s[3] - 48) * 10 + (s[4] - 48);\n    int giay_85 = (s[6] - 48) * 10 + (s[7] - 48);\n\n    // Kiem tra xem xau co dung dinh dang khong\n    if (gio_85 < 0 || gio_85 > 23 || phut_85 < 0 || phut_85 > 59 || giay_85 < 0 || giay_85 > 59)\n    {\n        cout << \"INCORRECT\";\n        return 0;\n    }\n\n    cout << gio_85 * 3600 + phut_85 * 60 + giay_85; // In ket qua\n}",
        "Bài 10": "// Phung Manh Hoang 20215385\n// Problem: Solve degree-2 polynomial equation\n\n#include <iostream>\n#include <math.h>\n\nusing namespace std;\n\nint main()\n{\n    int a_85, b_85, c_85;\n    double x1_85, x2_85;\n\n    cin >> a_85 >> b_85 >> c_85;                     // Nhap a, b, c\n    double delta_85 = b_85 * b_85 - 4 * a_85 * c_85; // Tinh delta\n\n    // Giai phuong trinh bac 2\n    if (delta_85 < 0)\n    {\n        cout << \"NO SOLUTION \"; // In ket qua\n    }\n    else if (delta_85 == 0)\n    {\n        x1_85 = x2_85 = -b_85 / (2 * a_85);\n        printf(\"%.2f\", x1_85); // In ket qua\n    }\n    else\n    {\n        delta_85 = sqrt(delta_85);\n        x1_85 = (-b_85 + delta_85) / (2 * a_85);\n        x2_85 = (-b_85 - delta_85) / (2 * a_85);\n\n        if (x1_85 < x2_85)\n            printf(\"%.2f %.2f\", x1_85, x2_85); // In ket qua\n        else\n            printf(\"%.2f %.2f\", x2_85, x1_85); // In ket qua\n    }\n}",
        "Bài 11": "// Phung Manh Hoang 20215385\n// Problem: Basic queries on array\n\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n    int n_85;\n    int arr_85[100000];\n    string s_85; // Nhap xau\n    int sum_85 = 0;\n    cin >> n_85; // Nhap n\n\n    // Nhap mang\n    for (int i = 0; i < n_85; i++)\n    {\n        cin >> arr_85[i];\n        sum_85 += arr_85[i];\n    }\n\n    while (s_85 != \"***\")\n    {\n        cin >> s_85;\n        if (s_85 == \"sum\")          // Tinh tong\n            cout << sum_85 << endl; // In ket qua\n        if (s_85 == \"find-max\")     // Tim max\n        {\n            int max_85 = arr_85[0];\n            for (int i = 1; i < n_85; i++)\n            {\n                max_85 = (max_85 < arr_85[i]) ? arr_85[i] : max_85;\n            }\n            cout << max_85 << endl; // In ket qua\n        }\n        if (s_85 == \"find-min\") // Tim min\n        {\n            int min_85 = arr_85[0];\n            for (int i = 1; i < n_85; i++)\n            {\n                min_85 = (min_85 > arr_85[i]) ? arr_85[i] : min_85;\n            }\n            cout << min_85 << endl; // In ket qua\n        }\n        if (s_85 == \"find-max-segment\") // Tim max tu x den y\n        {\n            int x_85, y_85;\n            cin >> x_85 >> y_85; // Nhap x, y\n            int max_85 = arr_85[x_85 - 1];\n            for (int i = x_85 - 1; i <= y_85 - 1; i++)\n            {\n                max_85 = (max_85 < arr_85[i]) ? arr_85[i] : max_85;\n            }\n            cout << max_85 << endl; // In ket qua\n        }\n    }\n}",
        "Bài 12": "// Phung Manh Hoang 20215385\n// Problem: k-Subsequence even\n\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n    int n_85, k_85;\n    int arr_85[100000];\n    int count_85 = 0;\n    int sum_85 = 0;\n\n    cin >> n_85 >> k_85; // Nhap n, k\n\n    // Nhap cac phan tu cua mang\n    for (int i = 0; i < n_85; i++)\n    {\n        cin >> arr_85[i];\n    }\n\n    int x = k_85 - 1;\n\n    // Dem so day con co tong cac phan tu bang so chan\n    if (x < n_85)\n    {\n\n        for (int j = 0; j <= x; j++)\n        {\n            sum_85 += arr_85[j];\n        }\n        if (sum_85 % 2 == 0)\n            count_85++;\n    }\n\n    // Dem so day con co tong cac phan tu bang so chan\n    for (int i = 1; i < n_85; i++)\n    {\n        if (i + k_85 - 1 < n_85)\n        {\n            sum_85 += arr_85[i + k_85 - 1] - arr_85[i - 1];\n            if (sum_85 % 2 == 0)\n                count_85++;\n        }\n    }\n    cout << count_85; // In ket qua\n}",
        "Bài 13": "// Phung Manh Hoang 20215385\n// Problem: Count words\n\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n    string s_85;\n    int count_85 = 0;\n\n    // Nhap va tinh so tu\n    while (cin >> s_85)\n    {\n        count_85++;\n    }\n\n    cout << count_85 << endl; // In ket qua\n}",
        "Bài 14": "// Phung Manh Hoang 20215385\n// Problem: Text Replacement\n\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n    string P1_85;\n    string P2_85;\n    string T_85;\n\n    getline(cin, P1_85); // Nhap sau P1\n    getline(cin, P2_85); // Nhap sau P2\n    getline(cin, T_85);  // Nhap sau T\n\n    // Doi cho hai xau P1 va P2 trong T\n    while (T_85.find(P1_85) != -1)\n        T_85.replace(T_85.find(P1_85), P1_85.size(), P2_85);\n    cout << T_85; // In ket qua\n}"
    },
    "Tuần 2": {
        "Bài 1": "// Phung Manh Hoang 20215385\n//  Problem: D\u00e3y fibonacci\n\n#include <iostream>\n\nusing namespace std;\n\nint fibonasi(int n_85)\n{\n    int fib_85[n_85 + 1];\n    fib_85[0] = 0;\n    fib_85[1] = 1;\n    for (int i = 2; i <= n_85; i++)\n    {\n        fib_85[i] = fib_85[i - 1] + fib_85[i - 2];\n    }\n    return fib_85[n_85];\n}\n\nint main()\n{\n    int n_85;\n    cin >> n_85;\n    cout << fibonasi(n_85 - 1);\n}",
        "Bài 2": "// Phung Manh Hoang 20215385\n//  Problem: Compute C_k_n\n#include <iostream>\nusing namespace std;\n#define ll long long\n#define mod (ll)(1e9 + 7)\n\n// Tinh x^y\nll power(ll x_85, ll y_85, ll p_85)\n{\n    ll res_85 = 1;\n    x_85 = x_85 % p_85;\n    while (y_85 > 0)\n    {\n        if (y_85 & 1)\n            res_85 = (res_85 * x_85) % p_85;\n        y_85 = y_85 >> 1;\n        x_85 = (x_85 * x_85) % p_85;\n    }\n    return res_85;\n}\n\n// Tinh n^(-1) mod p\nll modInverse(ll n_85, ll p_85)\n{\n    return power(n_85, p_85 - 2, p_85);\n}\n\n// Tinh n!\nll gt(int n_85)\n{\n    ll s_85 = 1;\n    for (int i = 1; i <= n_85; i++)\n    {\n        s_85 = (s_85 * i) % mod;\n    }\n    return s_85;\n}\n\n// Tinh C_k_n mod p\nll C_k_n(int k_85, int n_85, int p_85)\n{\n    return (gt(n_85) * modInverse(gt(k_85), p_85) % p_85 * modInverse(gt(n_85 - k_85), p_85) % p_85) % p_85;\n}\n\nint main()\n{\n    int k_85, n_85;\n    cin >> k_85 >> n_85;\n    cout << C_k_n(k_85, n_85, mod);\n}",
        "Bài 3": "// Phung Manh Hoang 20215385\n//  Problem: Binary sequence generation\n\n#include <iostream>\n\nusing namespace std;\n\nint x_85[100000];\n\n// In ket qua ra man hinh\nvoid print(int n_85)\n{\n    for (int i = 0; i < n_85; i++)\n    {\n        cout << x_85[i];\n    }\n    cout << endl;\n}\n\n// Ham sinh xau nhi phan\nvoid Solve(int k_85, int n_85)\n{\n    for (int i = 0; i <= 1; i++)\n    {\n        x_85[k_85 - 1] = i;\n        if (k_85 == n_85)\n        {\n            print(n_85);\n        }\n        else\n            Solve(k_85 + 1, n_85);\n    }\n}\n\nint main()\n{\n    int n_85;\n    cin >> n_85;\n    Solve(1, n_85);\n}",
        "Bài 4": "// Phung Manh Hoang 20215385\n//  Problem: Binary sequences generation without consecutive 11\n\n#include <iostream>\n\nusing namespace std;\n\nint x_85[100000];\n\n// In ket qua ra man hinh\nvoid print(int n_85)\n{\n    for (int i = 0; i < n_85; i++)\n    {\n        cout << x_85[i];\n    }\n    cout << endl;\n}\n\n// Ham sinh xau nhi phan ma khong co hai so 1 lien tiep\nvoid Solve(int k_85, int n_85)\n{\n    for (int i = 0; i <= 1; i++)\n    {\n\n        if (x_85[k_85 - 2] + i < 2 || k_85 == 1)\n        {\n            x_85[k_85 - 1] = i;\n            if (k_85 == n_85)\n                print(n_85);\n            else\n                Solve(k_85 + 1, n_85);\n        }\n    }\n}\n\nint main()\n{\n    int n_85;\n    cin >> n_85;\n    Solve(1, n_85);\n}",
        "Bài 5": "// Phung Manh Hoang 20215385\n//  Problem: Permutation generation\n\n#include <iostream>\n\nusing namespace std;\n\nint x_85[100000];\nint check_85[100000];\n\n// In ket qua ra man hinh\nvoid print(int n_85)\n{\n    for (int i = 1; i <= n_85; i++)\n    {\n        cout << x_85[i] << \" \";\n    }\n    cout << endl;\n}\n\n// Ham sinh hoan vi cua n\nvoid Solve(int k_85, int n_85)\n{\n    for (int i = 1; i <= n_85; i++)\n    {\n        if (!check_85[i])\n        {\n            x_85[k_85] = i;\n            check_85[i] = 1;\n            if (k_85 == n_85)\n                print(n_85);\n            else\n                Solve(k_85 + 1, n_85);\n            check_85[i] = 0;\n        }\n    }\n}\n\nint main()\n{\n    int n_85;\n    cin >> n_85;\n    Solve(1, n_85);\n}",
        "Bài 6": "// Phung Manh Hoang 20215385\n//  Problem: Count number of sudoku solutions\n\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int N_85 = 9;\nint grid_85[N_85][N_85];\n\n// Kiem tra xem ket qua dung khong\nbool is_valid(int row_85, int col_85, int num_85)\n{\n    for (int i = 0; i < N_85; i++)\n    {\n        if (grid_85[row_85][i] == num_85 || grid_85[i][col_85] == num_85)\n        {\n            return false;\n        }\n    }\n    int sub_row_85 = row_85 - row_85 % 3;\n    int sub_col_85 = col_85 - col_85 % 3;\n    for (int i = sub_row_85; i < sub_row_85 + 3; i++)\n    {\n        for (int j = sub_col_85; j < sub_col_85 + 3; j++)\n        {\n            if (grid_85[i][j] == num_85)\n            {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\n// Dem so dap an sodoku\nint solve(int row_85, int col_85)\n{\n    if (row_85 == N_85)\n    {\n        return 1;\n    }\n    if (col_85 == N_85)\n    {\n        return solve(row_85 + 1, 0);\n    }\n    if (grid_85[row_85][col_85] != 0)\n    {\n        return solve(row_85, col_85 + 1);\n    }\n    int count_85 = 0;\n    for (int i = 1; i <= N_85; i++)\n    {\n        if (is_valid(row_85, col_85, i))\n        {\n            grid_85[row_85][col_85] = i;\n            count_85 += solve(row_85, col_85 + 1);\n            grid_85[row_85][col_85] = 0;\n        }\n    }\n    return count_85;\n}\n\nint main()\n{\n    for (int i = 0; i < N_85; i++)\n    {\n        for (int j = 0; j < N_85; j++)\n        {\n            cin >> grid_85[i][j];\n        }\n    }\n    cout << solve(0, 0) << endl;\n}",
        "Bài 7": "// Phung Manh Hoang 20215385\n//  Problem: Linear Integer Equation - coefficent 1\n\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Ham sinh ra cac nghiem cua phuong trinh\nvoid Solve(int n_85, int M_85, vector<int> &prefix_85)\n{\n    if (n_85 == 0)\n    {\n        if (M_85 == 0)\n        {\n            for (int i = 0; i < prefix_85.size(); i++)\n            {\n                cout << prefix_85[i] << \" \";\n            }\n            cout << endl;\n        }\n        return;\n    }\n    for (int i = 1; i <= M_85; i++)\n    {\n        prefix_85.push_back(i);\n        Solve(n_85 - 1, M_85 - i, prefix_85);\n        prefix_85.pop_back();\n    }\n}\n\nint main()\n{\n    int n_85, M_85;\n    cin >> n_85 >> M_85;\n    vector<int> prefix_85;\n    Solve(n_85, M_85, prefix_85);\n    return 0;\n}\n"
    },
    "Tuần 3": {
        "Bài 1": "// Phung Manh Hoang 20215385\n// Problem: Simulation Stack\n\n#include <iostream>\n\nusing namespace std;\n\n// Tao cau truc Node\nstruct Node\n{\n    int data_85;\n    Node *next_85;\n};\n\n// Tao cau truc Stack\nstruct Stack\n{\n    int top_85;\n    Node *head_85;\n};\n\n// Khoi tao Stack\nStack initStack()\n{\n    Stack S_85;\n    S_85.top_85 = 0;\n    S_85.head_85 = NULL;\n    return S_85;\n}\n\n// Khoi tao Node\nNode *initNode(int data_85)\n{\n    Node *temp_85_85 = new Node();\n    temp_85_85->data_85 = data_85;\n    temp_85_85->next_85 = NULL;\n    return temp_85_85;\n}\n\n// Them Node vao Stack\nvoid Push(Stack &S_85, int data_85)\n{\n    Node *temp_85 = initNode(data_85);\n    temp_85->next_85 = S_85.head_85;\n    S_85.head_85 = temp_85;\n    S_85.top_85++;\n}\n\n// Xoa Node khoi Stack\nvoid Pop(Stack &S_85)\n{\n    if (S_85.top_85 > 0)\n    {\n        S_85.top_85--;\n        cout << S_85.head_85->data_85 << endl;\n        Node *temp_85 = S_85.head_85->next_85;\n        delete (S_85.head_85);\n        S_85.head_85 = temp_85;\n        return;\n    }\n    cout << \"NULL\" << endl;\n}\n\n// Xoa Stack\nvoid deleteStack(Stack &S_85)\n{\n    while (S_85.top_85 > 0)\n    {\n        Node *temp_85 = S_85.head_85->next_85;\n        delete (S_85.head_85);\n        S_85.head_85 = temp_85;\n        S_85.top_85--;\n    }\n}\n\nint main()\n{\n    Stack S_85 = initStack();\n    string str_85;\n    int x_85;\n\n    do\n    {\n        cin >> str_85;\n        // Them Node vao Stack\n        if (str_85 == \"PUSH\")\n        {\n            cin >> x_85;\n            Push(S_85, x_85);\n        }\n        // Xoa Node khoi Stack\n        else if (str_85 == \"POP\")\n            Pop(S_85);\n\n    } while (str_85 != \"#\");\n\n    deleteStack(S_85);\n}",
        "Bài 2": "// Phung Manh Hoang 20215385\n// Problem: Simulation Queue\n\n#include <iostream>\n\nusing namespace std;\n\n// Tao cau truc Node\nstruct Node\n{\n    int data_85;\n    Node *next_85;\n};\n\n// Tao cau truc Queue\nstruct Queue\n{\n    int top_85;\n    Node *head_85;\n};\n\n// Khoi tao Queue\nQueue initQueue()\n{\n    Queue S_85;\n    S_85.top_85 = 0;\n    S_85.head_85 = NULL;\n    return S_85;\n}\n\n// Khoi tao Node\nNode *initNode(int data_85)\n{\n    Node *temp_85 = new Node();\n    temp_85->data_85 = data_85;\n    temp_85->next_85 = NULL;\n    return temp_85;\n}\n\n// Them Node vao Queue\nvoid Push(Queue &S_85, int data_85)\n{\n    Node *temp_85 = initNode(data_85);\n    temp_85->next_85 = S_85.head_85;\n    S_85.head_85 = temp_85;\n    S_85.top_85++;\n}\n\n// Xoa Node khoi Queue\nvoid Pop(Queue &S_85)\n{\n\n    if (S_85.top_85 > 1)\n    {\n        S_85.top_85--;\n        Node *temp_85 = S_85.head_85;\n        while (S_85.head_85->next_85->next_85 != NULL)\n        {\n            S_85.head_85 = S_85.head_85->next_85;\n        }\n        cout << S_85.head_85->next_85->data_85 << endl;\n        delete (S_85.head_85->next_85);\n        S_85.head_85->next_85 = NULL;\n        S_85.head_85 = temp_85;\n        return;\n    }\n    else if (S_85.top_85 == 1)\n    {\n        S_85.top_85--;\n        cout << S_85.head_85->data_85 << endl;\n        delete (S_85.head_85);\n        S_85.head_85 = NULL;\n        return;\n    }\n    cout << \"NULL\" << endl;\n}\n\n// Xoa Queue\nvoid deleteQueue(Queue &S_85)\n{\n    while (S_85.top_85 > 0)\n    {\n        Node *temp_85 = S_85.head_85->next_85;\n        delete (S_85.head_85);\n        S_85.head_85 = temp_85;\n        S_85.top_85--;\n    }\n}\n\nint main()\n{\n    Queue S_85 = initQueue();\n    string str_85;\n    int x_85;\n\n    do\n    {\n        cin >> str_85;\n        // Them Node vao Queue\n        if (str_85 == \"PUSH\")\n        {\n            cin >> x_85;\n            Push(S_85, x_85);\n        }\n        // Xoa Node khoi Queue\n        else if (str_85 == \"POP\")\n            Pop(S_85);\n\n    } while (str_85 != \"#\");\n\n    deleteQueue(S_85);\n}",
        "Bài 3": "// Phung Manh Hoang 20215385\n// Problem: Check Parenthesis\n\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main()\n{\n    vector<char> vecStr_85;\n    string str_85;\n    cin >> str_85;\n\n    int size = str_85.size();\n    for (int i = 0; i < size; i++)\n    {\n        // Nhap vao mot chuoi ky tu (,{,[,],},)\n        if (str_85[i] == '(' || str_85[i] == '[' || str_85[i] == '{')\n        {\n            vecStr_85.push_back(str_85[i]);\n        }\n\n        // Kiem tra xem xau co dung khong\n        if (str_85[i] == ')' || str_85[i] == ']' || str_85[i] == '}')\n        {\n            if (vecStr_85.empty())\n            {\n                cout << \"0\";\n                return 0;\n            }\n\n            char c_85 = vecStr_85.back();\n\n            if (c_85 == '(' && str_85[i] == ')')\n            {\n                vecStr_85.pop_back();\n            }\n            else if (c_85 == '[' && str_85[i] == ']')\n            {\n                vecStr_85.pop_back();\n            }\n            else if (c_85 == '{' && str_85[i] == '}')\n            {\n                vecStr_85.pop_back();\n            }\n            else\n            {\n                cout << \"0\";\n                return 0;\n            }\n        }\n    }\n\n    if (vecStr_85.empty())\n    {\n        cout << \"1\";\n    }\n    else\n    {\n        cout << \"0\";\n    }\n}",
        "Bài 4": "// Phung Manh Hoang 20215385\n// Problem: WATER JUGS\n\n#include <iostream>\n#include <queue>\n#include <stack>\n#include <list>\n\nusing namespace std;\n\n// Tao cau truc State\nstruct State\n{\n    int x_85;\n    int y_85;\n    State *p_85;\n};\n\n// Khoi tao cac gia tri\nbool visited_85[10000][10000];\nqueue<State *> Q_85;\nlist<State *> L_85;\nState *target_85;\nint a_85, b_85, c_85;\n\n// Tao mang trang thai\nvoid initVisited()\n{\n    for (int x_85 = 0; x_85 < 10000; x_85++)\n        for (int y_85 = 0; y_85 < 10000; y_85++)\n            visited_85[x_85][y_85] = false;\n}\n\n// Kiem tra trang thai dich\nbool reachTarget(State *S_85)\n{\n    return S_85->x_85 == c_85 || S_85->y_85 == c_85 ||\n           S_85->x_85 + S_85->y_85 == c_85;\n}\n\n// Ham danh dau trang thai\nvoid markVisit(State *S_85)\n{\n    visited_85[S_85->x_85][S_85->y_85] = true;\n}\n\n// Giai phong bo nho\nvoid freeMemory()\n{\n    list<State *>::iterator it_85;\n    for (it_85 = L_85.begin(); it_85 != L_85.end(); it_85++)\n    {\n        delete *it_85;\n    }\n}\n\n// Do het nuoc tu coc 1 ra ngoai\nbool genMove1Out(State *S_85)\n{\n    if (visited_85[0][S_85->y_85])\n        return false;\n    State *newS_85 = new State;\n    newS_85->x_85 = 0;\n    newS_85->y_85 = S_85->y_85;\n    newS_85->p_85 = S_85;\n    Q_85.push(newS_85);\n    markVisit(newS_85);\n    L_85.push_back(newS_85);\n    if (reachTarget(newS_85))\n    {\n        target_85 = newS_85;\n        return true;\n    }\n    return false;\n}\n\n// Do het nuoc tu coc 2 ra ngoai\nbool genMove2Out(State *S_85)\n{\n    if (visited_85[S_85->x_85][0])\n        return false;\n    State *newS_85 = new State;\n    newS_85->x_85 = S_85->x_85;\n    newS_85->y_85 = 0;\n    newS_85->p_85 = S_85;\n    Q_85.push(newS_85);\n    markVisit(newS_85);\n    L_85.push_back(newS_85);\n    if (reachTarget(newS_85))\n    {\n        target_85 = newS_85;\n        return true;\n    }\n    return false;\n}\n\n// Do nuoc tu coc 1 vao day coc 2\nbool genMove1Full2(State *S_85)\n{\n    if (S_85->x_85 + S_85->y_85 < b_85)\n        return false;\n    if (visited_85[S_85->x_85 + S_85->y_85 - b_85][b_85])\n        return false;\n    State *newS_85 = new State;\n    newS_85->x_85 = S_85->x_85 + S_85->y_85 - b_85;\n    newS_85->y_85 = b_85;\n    newS_85->p_85 = S_85;\n    Q_85.push(newS_85);\n    markVisit(newS_85);\n    L_85.push_back(newS_85);\n    if (reachTarget(newS_85))\n    {\n        target_85 = newS_85;\n        return true;\n    }\n    return false;\n}\n\n// Do nuoc tu coc 2 vao day coc 1\nbool genMove2Full1(State *S_85)\n{\n    if (S_85->x_85 + S_85->y_85 < a_85)\n        return false;\n    if (visited_85[a_85][S_85->x_85 + S_85->y_85 - a_85])\n        return false;\n    State *newS_85 = new State;\n    newS_85->x_85 = a_85;\n    newS_85->y_85 = S_85->x_85 + S_85->y_85 - a_85;\n\n    newS_85->p_85 = S_85;\n    Q_85.push(newS_85);\n    markVisit(newS_85);\n    L_85.push_back(newS_85);\n    if (reachTarget(newS_85))\n    {\n        target_85 = newS_85;\n        return true;\n    }\n    return false;\n}\n\n// Do het nuoc tu coc 1 vao coc 2\nbool genMoveAll12(State *S_85)\n{\n    if (S_85->x_85 + S_85->y_85 > b_85)\n        return false;\n    if (visited_85[0][S_85->x_85 + S_85->y_85])\n        return false;\n    State *newS_85 = new State;\n    newS_85->x_85 = 0;\n    newS_85->y_85 = S_85->x_85 + S_85->y_85;\n\n    newS_85->p_85 = S_85;\n    Q_85.push(newS_85);\n    markVisit(newS_85);\n    L_85.push_back(newS_85);\n    if (reachTarget(newS_85))\n    {\n        target_85 = newS_85;\n        return true;\n    }\n    return false;\n}\n\n// Do het nuoc tu coc 2 vao coc 1\nbool genMoveAll21(State *S_85)\n{\n    if (S_85->x_85 + S_85->y_85 > a_85)\n        return false;\n    if (visited_85[S_85->x_85 + S_85->y_85][0])\n        return false;\n    State *newS_85 = new State;\n    newS_85->x_85 = S_85->x_85 + S_85->y_85;\n    newS_85->y_85 = 0;\n\n    newS_85->p_85 = S_85;\n    Q_85.push(newS_85);\n    markVisit(newS_85);\n    L_85.push_back(newS_85);\n    if (reachTarget(newS_85))\n    {\n        target_85 = newS_85;\n        return true;\n    }\n    return false;\n}\n\n// Do day nuoc tu be vao coc 1\nbool genMoveFill1(State *S_85)\n{\n    if (visited_85[a_85][S_85->y_85])\n        return false;\n    State *newS_85 = new State;\n    newS_85->x_85 = a_85;\n    newS_85->y_85 = S_85->y_85;\n\n    newS_85->p_85 = S_85;\n    Q_85.push(newS_85);\n    markVisit(newS_85);\n    L_85.push_back(newS_85);\n    if (reachTarget(newS_85))\n    {\n        target_85 = newS_85;\n        return true;\n    }\n    return false;\n}\n\n// Do day nuoc tu be vao coc 2\nbool genMoveFill2(State *S_85)\n{\n    if (visited_85[S_85->x_85][b_85])\n        return false;\n    State *newS_85 = new State;\n    newS_85->x_85 = S_85->x_85;\n    newS_85->y_85 = b_85;\n\n    newS_85->p_85 = S_85;\n    Q_85.push(newS_85);\n    markVisit(newS_85);\n    L_85.push_back(newS_85);\n    if (reachTarget(newS_85))\n    {\n        target_85 = newS_85;\n        return true;\n    }\n    return false;\n}\n\n// In ra ket qua\nvoid print(State *target_85)\n{\n    if (target_85 == NULL)\n    {\n        cout << -1;\n        return;\n    }\n\n    State *currentS_85 = target_85;\n    stack<State *> actions_85;\n    while (currentS_85 != NULL)\n    {\n        actions_85.push(currentS_85);\n        currentS_85 = currentS_85->p_85;\n    }\n    cout << actions_85.size() - 1;\n}\n\n// Giai bai toan\nvoid solve()\n{\n    initVisited();\n    // sinh ra trang thai ban dau (0,0) va dua vao Q_85\n    State *S_85 = new State;\n    S_85->x_85 = 0;\n    S_85->y_85 = 0;\n    S_85->p_85 = NULL;\n    Q_85.push(S_85);\n    markVisit(S_85);\n    while (!Q_85.empty())\n    {\n        State *S_85 = Q_85.front();\n        Q_85.pop();\n        if (genMove1Out(S_85))\n            break;\n        if (genMove2Out(S_85))\n            break;\n        if (genMove1Full2(S_85))\n            break;\n        if (genMoveAll12(S_85))\n            break;\n        if (genMove2Full1(S_85))\n            break;\n        if (genMoveAll21(S_85))\n            break;\n        if (genMoveFill1(S_85))\n            break;\n        if (genMoveFill2(S_85))\n            break;\n    }\n}\n\nint main()\n{\n    cin >> a_85 >> b_85 >> c_85;\n    target_85 = NULL;\n    solve();\n    print(target_85);\n    freeMemory();\n}",
        "Bài 5": "// Phung Manh Hoang 20215385\n// Problem: Tree manipulation & Traversal\n\n#include <iostream>\n\nusing namespace std;\n\n// Tao cau truc Node\ntypedef struct Node\n{\n    int data_85;\n    Node *leftMostChild_85;\n    Node *rightSibling_85;\n} Node;\n\n// Khoi tao Node\nNode *initNode()\n{\n    Node *root_85 = NULL;\n    return root_85;\n}\n\n// Tao Node moi\nNode *newNode(Node *root_85, int x_85)\n{\n    Node *node_85 = new Node;\n    node_85->data_85 = x_85;\n    node_85->leftMostChild_85 = NULL;\n    node_85->rightSibling_85 = NULL;\n    return node_85;\n}\n\n// Tim Node co gia tri x\nNode *findNode(Node *root_85, int x_85)\n{\n    if (root_85 == NULL)\n        return NULL;\n    if (root_85->data_85 == x_85)\n        return root_85;\n    Node *p_85 = root_85->leftMostChild_85;\n    while (p_85 != NULL)\n    {\n        Node *q_85 = findNode(p_85, x_85);\n        if (q_85 != NULL)\n            return q_85;\n        p_85 = p_85->rightSibling_85;\n    }\n    return NULL;\n}\n\n// Chen Node moi vao cay\nNode *insertNode(Node *root_85, Node *p_85, int x_85)\n{\n    if (root_85 == NULL)\n    {\n        Node *node_85 = newNode(root_85, x_85);\n        return node_85;\n    }\n    Node *l_85 = p_85->leftMostChild_85;\n    if (l_85 == NULL)\n    {\n        p_85->leftMostChild_85 = newNode(root_85, x_85);\n        return root_85;\n    }\n    while (l_85->rightSibling_85 != NULL)\n    {\n        l_85 = l_85->rightSibling_85;\n    }\n    l_85->rightSibling_85 = newNode(root_85, x_85);\n    return root_85;\n}\n\n// In ra cay theo InOrder\nvoid printInOrder(Node *root_85)\n{\n    if (root_85 == NULL)\n        return;\n    Node *p_85 = root_85->leftMostChild_85;\n    printInOrder(p_85);\n\n    cout << root_85->data_85 << \" \";\n\n    if (p_85 != NULL)\n        p_85 = p_85->rightSibling_85;\n\n    while (p_85 != NULL)\n    {\n        printInOrder(p_85);\n        p_85 = p_85->rightSibling_85;\n    }\n}\n\n// In ra cay theo PreOrder\nvoid printPreOrder(Node *root_85)\n{\n    if (root_85 == NULL)\n        return;\n    cout << root_85->data_85 << \" \";\n    Node *p_85 = root_85->leftMostChild_85;\n    while (p_85 != NULL)\n    {\n        printPreOrder(p_85);\n        p_85 = p_85->rightSibling_85;\n    }\n}\n\n// In ra cay theo PostOrder\nvoid printPostOrder(Node *root_85)\n{\n    if (root_85 == NULL)\n        return;\n    Node *p_85 = root_85->leftMostChild_85;\n    while (p_85 != NULL)\n    {\n        printPostOrder(p_85);\n        p_85 = p_85->rightSibling_85;\n    }\n    cout << root_85->data_85 << \" \";\n}\n\nint main()\n{\n    string s_85;\n    Node *root_85 = initNode();\n\n    do\n    {\n        cin >> s_85;\n        // Tao Node moi\n        if (s_85 == \"MakeRoot\")\n        {\n            int u_85;\n            cin >> u_85;\n            root_85 = newNode(root_85, u_85);\n        }\n        // Chen Node moi vao cay\n        else if (s_85 == \"Insert\")\n        {\n            int u_85, v_85;\n            cin >> u_85 >> v_85;\n\n            Node *node = findNode(root_85, v_85);\n            root_85 = insertNode(root_85, node, u_85);\n        }\n        // In ra cay theo PreOrder\n        else if (s_85 == \"PreOrder\")\n        {\n            printPreOrder(root_85);\n            cout << endl;\n        }\n        // In ra cay theo InOrder\n        else if (s_85 == \"InOrder\")\n        {\n            printInOrder(root_85);\n            cout << endl;\n        }\n        // In ra cay theo PostOrder\n        else if (s_85 == \"PostOrder\")\n        {\n            printPostOrder(root_85);\n            cout << endl;\n        }\n    } while (s_85 != \"*\");\n}",
        "Bài 6": "// Phung Manh Hoang 20215385\n// Problem: Family Tree\n\n#include <iostream>\n\nusing namespace std;\n\n// Tao cau truc Node\ntypedef struct Node\n{\n    string name_85;\n    Node *leftMostChild_85;\n    Node *rightSibling_85;\n} Node;\n\n// Khoi tao Node\nNode *initNode()\n{\n    Node *root_85 = NULL;\n    return root_85;\n}\n\n// Tao Node moi\nNode *newNode(Node *root_85, string name_85)\n{\n    Node *node_85 = new Node;\n    node_85->name_85 = name_85;\n    node_85->leftMostChild_85 = NULL;\n    node_85->rightSibling_85 = NULL;\n    return node_85;\n}\n\n// Tim Node co gia tri name\nNode *findNode(Node *root_85, string name_85)\n{\n    if (root_85 == NULL)\n        return NULL;\n    if (root_85->name_85 == name_85)\n        return root_85;\n    Node *p_85 = root_85->leftMostChild_85;\n    while (p_85 != NULL)\n    {\n        Node *q_85 = findNode(p_85, name_85);\n        if (q_85 != NULL)\n            return q_85;\n        p_85 = p_85->rightSibling_85;\n    }\n    return NULL;\n}\n\n// Chen Node moi vao cay\nNode *insertNode(Node *root_85, Node *p_85, string name_85)\n{\n    if (root_85 == NULL)\n    {\n        Node *node = newNode(root_85, name_85);\n        return node;\n    }\n    Node *l_85 = p_85->leftMostChild_85;\n    if (l_85 == NULL)\n    {\n        p_85->leftMostChild_85 = newNode(root_85, name_85);\n        return root_85;\n    }\n    while (l_85->rightSibling_85 != NULL)\n    {\n        l_85 = l_85->rightSibling_85;\n    }\n    l_85->rightSibling_85 = newNode(root_85, name_85);\n    return root_85;\n}\n\n// Dem so node con cua 1 node\nint countNode(Node *root_85)\n{\n    if (root_85 == NULL)\n        return 0;\n    int count_85 = 1;\n    Node *p_85 = root_85->leftMostChild_85;\n    while (p_85 != NULL)\n    {\n        count_85 += countNode(p_85);\n        p_85 = p_85->rightSibling_85;\n    }\n    return count_85;\n}\n\n// Tim chieu cao cua 1 node\nint height(Node *root_85)\n{\n    if (root_85 == NULL)\n        return 0;\n    int h_85 = 0;\n    Node *p_85 = root_85->leftMostChild_85;\n    while (p_85 != NULL)\n    {\n        h_85 = max(h_85, height(p_85));\n        p_85 = p_85->rightSibling_85;\n    }\n    return h_85 + 1;\n}\n\n// Kiem tra 1 node co phai la con cua 1 node khac hay khong\nbool isChild_85(Node *parent_85, string nameChild_85)\n{\n    if (parent_85 == NULL)\n        return false;\n    Node *p_85 = parent_85->leftMostChild_85;\n    while (p_85 != NULL)\n    {\n        if (p_85->name_85 == nameChild_85)\n            return true;\n        p_85 = p_85->rightSibling_85;\n    }\n    return false;\n}\n\n// Them 1 node vao cuoi cua 1 node khac\nNode *addNode(Node *root_85, Node *parent_85, Node *child_85)\n{\n    if (root_85 == NULL)\n        return NULL;\n\n    Node *l_85 = parent_85->leftMostChild_85;\n    if (l_85 == NULL)\n    {\n        parent_85->leftMostChild_85 = child_85;\n        return root_85;\n    }\n    while (l_85->rightSibling_85 != NULL)\n    {\n        l_85 = l_85->rightSibling_85;\n    }\n    l_85->rightSibling_85 = child_85;\n    return root_85;\n}\n\n// Chuyen 1 node tu vi tri hien tai sang vi tri moi\nNode *transferNode(Node *root_85, Node *parent_85, string nameChild_85)\n{\n    if (root_85 == NULL)\n        return NULL;\n    if (isChild_85(parent_85, nameChild_85))\n        return root_85;\n\n    Node *l_85 = root_85->leftMostChild_85;\n\n    while (l_85 != NULL)\n    {\n        if (l_85->rightSibling_85->name_85 == nameChild_85)\n        {\n            Node *p_85 = l_85->rightSibling_85;\n            l_85->rightSibling_85 = l_85->rightSibling_85->rightSibling_85;\n            p_85->rightSibling_85 = NULL;\n            root_85 = addNode(root_85, parent_85, p_85);\n            return root_85;\n        }\n        else\n            l_85 = l_85->rightSibling_85;\n    }\n\n    return root_85;\n}\n\nint main()\n{\n    string nameChild_85, nameParent_85;\n    Node *root_85 = initNode();\n\n    while (true)\n    {\n        cin >> nameChild_85;\n        if (nameChild_85 == \"***\")\n            break;\n        cin >> nameParent_85;\n\n        // Khoi tao cay va them node moi\n        if (root_85 == NULL)\n        {\n            root_85 = newNode(root_85, nameParent_85);\n            root_85 = insertNode(root_85, root_85, nameChild_85);\n        }\n        else\n        {\n            Node *parent_85 = findNode(root_85, nameParent_85);\n            Node *child_85 = findNode(root_85, nameChild_85);\n            if (parent_85 == NULL)\n            {\n                root_85 = insertNode(root_85, root_85, nameParent_85);\n                Node *p = findNode(root_85, nameParent_85);\n                if (child_85 == NULL)\n                {\n\n                    root_85 = insertNode(root_85, p, nameChild_85);\n                }\n                else\n                {\n                    root_85 = transferNode(root_85, p, nameChild_85);\n                }\n            }\n            else\n            {\n                if (child_85 == NULL)\n                {\n                    root_85 = insertNode(root_85, parent_85, nameChild_85);\n                }\n                else\n                {\n                    root_85 = transferNode(root_85, parent_85, nameChild_85);\n                }\n            }\n        }\n    }\n\n    string cmd_85, param_85;\n\n    do\n    {\n        cin >> cmd_85;\n        if (cmd_85 == \"***\")\n            break;\n        // In ra so Node con cua 1 Node\n        if (cmd_85 == \"descendants\")\n        {\n            cin >> param_85;\n            cout << countNode(findNode(root_85, param_85)) - 1 << endl;\n        }\n        // In ra chieu cao cua 1 Node\n        else if (cmd_85 == \"generation\")\n        {\n            cin >> param_85;\n            cout << height(findNode(root_85, param_85)) - 1 << endl;\n        }\n\n    } while (cmd_85 != \"***\");\n}",
        "Bài 7": "// Phung Manh Hoang 20215385\n// Problem: BST - Insertion and PreOrder Traversal\n\n#include <iostream>\n\nusing namespace std;\n\n// Tao cau truc Tree\ntypedef struct BinaryTree\n{\n    int data_85;\n    BinaryTree *left_85;\n    BinaryTree *right_85;\n} Tree;\n\n// Khoi tao Tree\nTree *initTree()\n{\n    Tree *root_85 = NULL;\n    return root_85;\n}\n\n// Tao Node moi\nTree *newNode(Tree *root_85, int x_85)\n{\n    Tree *Node_85 = new Tree;\n    Node_85->data_85 = x_85;\n    Node_85->left_85 = NULL;\n    Node_85->right_85 = NULL;\n    return Node_85;\n}\n\n// Chen Node moi vao cay\nTree *insertNode(Tree *root_85, int x_85)\n{\n    if (root_85 == NULL)\n    {\n        Tree *Node_85 = newNode(root_85, x_85);\n        return Node_85;\n    }\n\n    if (x_85 <= root_85->data_85)\n    {\n        root_85->left_85 = insertNode(root_85->left_85, x_85);\n    }\n    else\n    {\n        root_85->right_85 = insertNode(root_85->right_85, x_85);\n    }\n    return root_85;\n}\n\n// Duyet cay theo thu tu truoc\nvoid printPreOrder(Tree *root_85)\n{\n    if (root_85 == NULL)\n    {\n        return;\n    }\n\n    cout << root_85->data_85 << \" \";\n    printPreOrder(root_85->left_85);\n    printPreOrder(root_85->right_85);\n}\n\n// Tim Node co gia tri x\nbool findNode(Tree *root_85, int x_85)\n{\n    if (root_85 == NULL)\n    {\n        return false;\n    }\n\n    if (root_85->data_85 == x_85)\n    {\n        return true;\n    }\n\n    if (x_85 <= root_85->data_85)\n    {\n        return findNode(root_85->left_85, x_85);\n    }\n    else\n    {\n        return findNode(root_85->right_85, x_85);\n    }\n}\n\n// Xoa cay\nvoid deleteTree(Tree *root_85)\n{\n    if (root_85 == nullptr)\n    {\n        return;\n    }\n\n    deleteTree(root_85->left_85);\n    deleteTree(root_85->right_85);\n    delete root_85;\n}\n\nint main()\n{\n    Tree *root_85 = initTree();\n    string s_85;\n\n    do\n    {\n        cin >> s_85;\n        if (s_85 == \"#\")\n            break;\n        // Chen Node moi vao cay\n        if (s_85 == \"insert\")\n        {\n            int x_85;\n            cin >> x_85;\n            if (findNode(root_85, x_85) == false)\n            {\n                root_85 = insertNode(root_85, x_85);\n            }\n        }\n    } while (s_85 != \"#\");\n\n    printPreOrder(root_85);\n    deleteTree(root_85);\n}",
        "Bài 8": "// Phung Manh Hoang 20215385\n// Problem: Insert at the middle of a sequence\n\n#include <iostream>\n\nusing namespace std;\n\n// Tao cau truc Node\nstruct Node\n{\n    int data_85;\n    Node *next_85;\n};\n\n// Tao Node danh dau\nNode *mark_85 = NULL;\n\n// Khoi tao Head\nNode *initHead()\n{\n    Node *head_85 = NULL;\n    return head_85;\n}\n\n// Tao Node moi\nNode *newNode(int value_85)\n{\n    Node *temp_85;\n    temp_85 = new Node;\n    temp_85->next_85 = NULL;\n    temp_85->data_85 = value_85;\n    return temp_85;\n}\n\n// Chen Node moi vao dau\nNode *addHead(Node *head_85, int value_85)\n{\n    Node *temp_85 = newNode(value_85);\n    if (head_85 == NULL)\n    {\n        return temp_85;\n    }\n    temp_85->next_85 = head_85;\n    return temp_85;\n}\n\n// Chen Node moi vao cuoi\nNode *addTail(Node *head_85, int value_85)\n{\n    Node *temp_85 = newNode(value_85);\n    if (head_85 == NULL)\n    {\n        return temp_85;\n    }\n    Node *p_85 = head_85;\n    while (p_85->next_85 != NULL)\n    {\n        p_85 = p_85->next_85;\n    }\n    p_85->next_85 = temp_85;\n    return head_85;\n}\n\n// Chen Node moi vao vi tri giua\nNode *addAt(Node *head_85, int value_85, int n_85)\n{\n    if (n_85 % 2 == 0)\n    {\n        int index_85 = n_85 / 2;\n        if (index_85 == 0)\n        {\n            head_85 = addHead(head_85, value_85);\n            mark_85 = head_85;\n            return head_85;\n        }\n        Node *temp_85 = newNode(value_85);\n        if (head_85 == NULL)\n        {\n            mark_85 = temp_85;\n            return temp_85;\n        }\n        int i_85 = 1;\n        Node *p_85 = head_85;\n        while (i_85 != index_85)\n        {\n            p_85 = p_85->next_85;\n            i_85++;\n        }\n        temp_85->next_85 = p_85->next_85;\n        p_85->next_85 = temp_85;\n        mark_85 = p_85->next_85;\n        return head_85;\n    }\n    else\n    {\n        int index_85 = n_85 / 2 + 1;\n        Node *temp_85 = newNode(value_85);\n        int i_85 = 1;\n        Node *p_85 = head_85;\n        while (i_85 != index_85)\n        {\n            p_85 = p_85->next_85;\n            i_85++;\n        }\n        temp_85->next_85 = p_85->next_85;\n        p_85->next_85 = temp_85;\n        mark_85 = p_85;\n        return head_85;\n    }\n}\n\n// Chen Node moi vao vi tri danh dau\nNode *addMark(Node *head_85, int value_85, int n_85)\n{\n    Node *temp_85 = newNode(value_85);\n    temp_85->next_85 = mark_85->next_85;\n    mark_85->next_85 = temp_85;\n    if (n_85 % 2 == 0)\n        mark_85 = mark_85->next_85;\n    else\n        mark_85 = mark_85;\n    return head_85;\n}\n\n// In ra danh sach\nvoid printNode(Node *head_85)\n{\n    Node *p_85 = head_85;\n\n    while (p_85 != NULL)\n    {\n        cout << p_85->data_85 << \" \";\n        p_85 = p_85->next_85;\n    }\n    cout << endl;\n}\n\n// Giai phong bo nho\nvoid freeNode(Node *head_85)\n{\n    Node *p_85 = head_85;\n    while (p_85 != NULL)\n    {\n        Node *temp_85 = p_85;\n        p_85 = p_85->next_85;\n        delete temp_85;\n    }\n}\n\nint main()\n{\n    int n_85;\n    Node *head_85 = initHead();\n    cin >> n_85;\n\n    // Khoi tao cay va them node\n    for (int i = 0; i < n_85; i++)\n    {\n        int value_85;\n        cin >> value_85;\n        head_85 = addTail(head_85, value_85);\n    }\n\n    string s_85;\n    do\n    {\n        cin >> s_85;\n        if (s_85 == \"#\")\n        {\n            break;\n        }\n        // Chen Node moi vao vi tri giua\n        else if (s_85 == \"ADD\")\n        {\n            int x_85;\n            cin >> x_85;\n            if (mark_85 == NULL)\n            {\n                head_85 = addAt(head_85, x_85, n_85);\n                n_85++;\n            }\n            else\n            {\n                head_85 = addMark(head_85, x_85, n_85);\n                n_85++;\n            }\n        }\n        else if (s_85 == \"PRINT\")\n        {\n            printNode(head_85);\n        }\n    } while (s_85 != \"#\");\n\n    freeNode(head_85);\n}",
        "Bài 9": "// Phung Manh Hoang 20215385\n// Problem: Linked List Manipulation\n\n#include <iostream>\n\nusing namespace std;\n\n// Tao cau truc Node\nstruct Node\n{\n    int data_85;\n    Node *next_85;\n};\n\n// Khoi tao Head\nNode *initHead()\n{\n    Node *head_85 = NULL;\n    return head_85;\n}\n\n// Tao Node moi\nNode *newNode(int value_85)\n{\n    Node *temp_85;\n    temp_85 = new Node;\n    temp_85->next_85 = NULL;\n    temp_85->data_85 = value_85;\n    return temp_85;\n}\n\n// Chen Node moi vao dau\nNode *addHead(Node *head_85, int value_85)\n{\n    Node *temp_85 = newNode(value_85);\n    if (head_85 == NULL)\n    {\n        return temp_85;\n    }\n    temp_85->next_85 = head_85;\n    return temp_85;\n}\n\n// Chen Node moi vao cuoi\nNode *addTail(Node *head_85, int value_85)\n{\n    Node *temp_85 = newNode(value_85);\n    if (head_85 == NULL)\n    {\n        return temp_85;\n    }\n    Node *p_85 = head_85;\n    while (p_85->next_85 != NULL)\n    {\n        p_85 = p_85->next_85;\n    }\n    p_85->next_85 = temp_85;\n    return head_85;\n}\n\n// Chen Node moi vao sau Node co gia tri u\nNode *addAfter(Node *head_85, int u_85, int v_85)\n{\n    Node *temp_85 = newNode(u_85);\n    if (head_85 == NULL)\n    {\n        return head_85;\n    }\n    Node *p_85 = head_85;\n    while (p_85 != NULL)\n    {\n        if (p_85->data_85 == v_85)\n        {\n            temp_85->next_85 = p_85->next_85;\n            p_85->next_85 = temp_85;\n            return head_85;\n        }\n        p_85 = p_85->next_85;\n    }\n    return head_85;\n}\n\n// Chen Node moi vao truoc Node co gia tri u\nNode *addBefore(Node *head_85, int u_85, int v_85)\n{\n    Node *temp_85 = newNode(u_85);\n    if (head_85 == NULL)\n    {\n        return head_85;\n    }\n    if (head_85->data_85 == v_85)\n    {\n        temp_85->next_85 = head_85;\n        return temp_85;\n    }\n    Node *p_85 = head_85;\n    while (p_85->next_85 != NULL)\n    {\n        if (p_85->next_85->data_85 == v_85)\n        {\n            temp_85->next_85 = p_85->next_85;\n            p_85->next_85 = temp_85;\n            return head_85;\n        }\n        p_85 = p_85->next_85;\n    }\n    return head_85;\n}\n\n// Xoa Node co gia tri value\nNode *remode(Node *head_85, int value_85)\n{\n    if (head_85 == NULL)\n    {\n        return head_85;\n    }\n    if (head_85->data_85 == value_85)\n    {\n        return head_85->next_85;\n    }\n    Node *p_85 = head_85;\n    while (p_85->next_85 != NULL)\n    {\n        if (p_85->next_85->data_85 == value_85)\n        {\n            p_85->next_85 = p_85->next_85->next_85;\n            return head_85;\n        }\n        p_85 = p_85->next_85;\n    }\n    return head_85;\n}\n\n// Tim Node co gia tri  value\nbool findNode(Node *head_85, int value_85)\n{\n    Node *p_85 = head_85;\n    while (p_85 != NULL)\n    {\n        if (p_85->data_85 == value_85)\n        {\n            return true;\n        }\n        p_85 = p_85->next_85;\n    }\n    return false;\n}\n\n// In ra danh sach\nvoid printNode(Node *head_85)\n{\n    Node *p_85 = head_85;\n\n    while (p_85 != NULL)\n    {\n        cout << p_85->data_85 << \" \";\n        p_85 = p_85->next_85;\n    }\n    cout << \"\\n\";\n}\n\n// Dao nguoc danh sach\nNode *reverseNode(Node *head_85)\n{\n    if (head_85 == NULL || head_85->next_85 == NULL)\n    {\n        return head_85;\n    }\n    Node *i_85 = NULL, *j_85 = head_85, *k_85 = head_85->next_85;\n    while (j_85 != NULL)\n    {\n        j_85->next_85 = i_85;\n        i_85 = j_85;\n        j_85 = k_85;\n        if (j_85 != NULL)\n            k_85 = j_85->next_85;\n    }\n    return i_85;\n}\n\n// Giai phong danh sach\nvoid freeNode(Node *head_85)\n{\n    Node *p_85 = head_85;\n    while (p_85 != NULL)\n    {\n        head_85 = head_85->next_85;\n        delete p_85;\n        p_85 = head_85;\n    }\n}\n\nint main()\n{\n    int n_85, x_85;\n    Node *head_85 = initHead();\n\n    cin >> n_85;\n    for (int i = 0; i < n_85; i++)\n    {\n        cin >> x_85;\n        head_85 = addTail(head_85, x_85);\n    }\n\n    string s_85;\n    do\n    {\n        cin >> s_85;\n        if (s_85 == \"#\")\n            break;\n        // Chen Node moi vao vi tri cuoi\n        if (s_85 == \"addlast\")\n        {\n            cin >> x_85;\n            if (!findNode(head_85, x_85))\n                head_85 = addTail(head_85, x_85);\n        }\n        // Chen Node moi vao vi tri dau\n        else if (s_85 == \"addfirst\")\n        {\n            cin >> x_85;\n            if (!findNode(head_85, x_85))\n                head_85 = addHead(head_85, x_85);\n        }\n        // Chen Node moi vao sau Node co gia tri x\n        else if (s_85 == \"addafter\")\n        {\n            int y_85;\n            cin >> x_85 >> y_85;\n            if (!findNode(head_85, x_85) && findNode(head_85, y_85))\n                head_85 = addAfter(head_85, x_85, y_85);\n        }\n        // Chen Node moi vao truoc Node co gia tri x\n        else if (s_85 == \"addbefore\")\n        {\n            int y_85;\n            cin >> x_85 >> y_85;\n            if (!findNode(head_85, x_85) && findNode(head_85, y_85))\n                head_85 = addBefore(head_85, x_85, y_85);\n        }\n        // Xoa Node co gia tri x\n        else if (s_85 == \"remove\")\n        {\n            cin >> x_85;\n            head_85 = remode(head_85, x_85);\n        }\n        // Dao nguoc danh sach\n        else if (s_85 == \"reverse\")\n        {\n            head_85 = reverseNode(head_85);\n        }\n    } while (s_85 != \"#\");\n\n    printNode(head_85);\n    freeNode(head_85);\n}"
    },
    "Tuần 4": {
        "Bài 1": "// Phung Manh Hoang 20215385\n// Problem: Store & Search String\n\n#include <iostream>\n#include <map>\n\nusing namespace std;\n\nint main()\n{\n    map<string, int> mapKey_85;\n    string s_85;\n\n    // Nhap cac key vao map\n    while (true)\n    {\n        cin >> s_85;\n        if (s_85 == \"*\")\n            break;\n        mapKey_85[s_85] = 1;\n    }\n\n    // Thuc hien truy van\n    while (true)\n    {\n        cin >> s_85;\n        if (s_85 == \"***\")\n            break;\n        // Kiem tra xem co ton tai keytrong map hay khong\n        if (s_85 == \"find\")\n        {\n            string key_85;\n            cin >> key_85;\n\n            if (mapKey_85.count(key_85) > 0)\n                cout << \"1\" << endl;\n            else\n                cout << \"0\" << endl;\n        }\n        // Them key vao map\n        else if (s_85 == \"insert\")\n        {\n            string key_85;\n            cin >> key_85;\n\n            if (mapKey_85.count(key_85) > 0)\n                cout << \"0\" << endl;\n            else\n            {\n                mapKey_85[key_85] = 1;\n                cout << \"1\" << endl;\n            }\n        }\n    }\n}",
        "Bài 2": "// Phung Manh Hoang 20215385\n// Problem: Hash Over Strings\n\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Tinh luy thua 256^n % m\nvoid pow(vector<int> &vecPow_85, int m_85)\n{\n    vecPow_85.push_back(1);\n    for (int i = 1; i < 220; i++)\n    {\n        vecPow_85.push_back((vecPow_85[i - 1] * 256) % m_85);\n    }\n}\n\nint main()\n{\n    vector<int> vecPow_85;\n    int n_85, m_85, H_85 = 0;\n    string s_85;\n\n    cin >> n_85 >> m_85;\n\n    pow(vecPow_85, m_85);\n\n    // Tinh ma bam cua tung xau\n    for (int i = 0; i < n_85; i++)\n    {\n        cin >> s_85;\n        int size_85 = s_85.size() - 1;\n        for (auto j : s_85)\n        {\n            H_85 += ((j % m_85) * vecPow_85[size_85]) % m_85;\n            size_85--;\n        }\n        cout << H_85 % m_85 << endl;\n        H_85 = 0;\n    }\n}",
        "Bài 3": "// Phung Manh Hoang 20215385\n// Problem: Ki\u1ec3m tra xu\u1ea5t hi\u1ec7n\n#include <iostream>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\nint main()\n{\n    int n_85, x_85;\n    vector<int> vec_85;\n    map<int, int> check_85;\n\n    // Nhap vector ban dau\n    cin >> n_85;\n    for (int i = 0; i < n_85; i++)\n    {\n        cin >> x_85;\n        vec_85.push_back(x_85);\n        check_85[x_85] = 0;\n    }\n\n    // Kiem tra xem x co xuat hien trong vector ban dau hay khong\n    for (int i = 0; i < n_85; i++)\n    {\n        if (check_85[vec_85[i]] == 0)\n        {\n            cout << \"0\" << endl;\n            check_85[vec_85[i]] = 1;\n        }\n        else\n        {\n            cout << \"1\" << endl;\n        }\n    }\n}",
        "Bài 4": "// Phung Manh Hoang 20215385\n// Problem: Sum pair of sequence equal to a number\n\n#include <iostream>\n#include <map>\nusing namespace std;\n\nint main()\n{\n    int n_85, M_85;\n    cin >> n_85 >> M_85;\n    int a_85[n_85];\n    // Nhap mang ban dau\n    for (int i = 0; i < n_85; i++)\n    {\n        cin >> a_85[i];\n    }\n\n    // Dem so cap co tong bang M\n    map<int, int> hash_table_85;\n    int Q_85 = 0;\n    for (int i = 0; i < n_85; i++)\n    {\n        if (hash_table_85.find(M_85 - a_85[i]) != hash_table_85.end())\n        {\n            Q_85++;\n        }\n        hash_table_85[a_85[i]] = i;\n    }\n    cout << Q_85 << endl;\n}\n"
    },
    "Tuần 5": {
        "Bài 1": "// Ph\u00f9ng M\u1ea1nh Ho\u00e0ng 20215385\n// Problem: Week 5 - Minimum Spanning Tree - Kruskal\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Edge // \u0110\u1ecbnh ngh\u0129a c\u1ea5u tr\u00fac Edge\n{\n    int u_85, v_85, w_85;\n};\n\nint parent_85[100000]; // M\u1ea3ng l\u01b0u tr\u1eef cha c\u1ee7a m\u1ed7i n\u00fat\nint hang_85[100000];   // M\u1ea3ng l\u01b0u tr\u1eef h\u1ea1ng c\u1ee7a m\u1ed7i n\u00fat\n\nint find(int u_85) // H\u00e0m t\u00ecm cha c\u1ee7a n\u00fat u_85\n{\n    if (parent_85[u_85] != u_85)\n        parent_85[u_85] = find(parent_85[u_85]);\n    return parent_85[u_85];\n}\n\n// H\u00e0m h\u1ee3p nh\u1ea5t 2 c\u00e2y ch\u1ee9a u v\u00e0 v,\n// Tr\u1ea3 v\u1ec1 false n\u1ebfu kh\u00f4ng th\u1ec3 h\u1ee3p nh\u1ea5t\nbool join(int u_85, int v_85)\n{\n    u_85 = find(u_85);\n    v_85 = find(v_85);\n    if (u_85 == v_85)\n        return false;\n    if (hang_85[u_85] == hang_85[v_85])\n        hang_85[u_85]++;\n    if (hang_85[u_85] < hang_85[v_85])\n        parent_85[u_85] = v_85;\n    else\n        parent_85[v_85] = u_85;\n    return true;\n}\n\nint main()\n{\n    ios::sync_with_stdio(false); // T\u1eaft \u0111\u1ed3ng b\u1ed9 gi\u1eefa C v\u00e0 C++ streams\n    cin.tie(0);                  // Kh\u00f4ng li\u00ean k\u1ebft cin v\u1edbi cout\n\n    int N_85, M_85; // Kh\u1edfi t\u1ea1o v\u00e0 nh\u1eadp v\u00e0o n v\u00e0 m\n    vector<Edge> edges_85;\n    cin >> N_85 >> M_85;\n\n    int u_85, v_85, w_85; // Kh\u1edfi t\u1ea1o v\u00e0 nh\u1eadp v\u00e0o c\u00e1c c\u1ea1nh\n    for (int i = 0; i < M_85; i++)\n    {\n        cin >> u_85 >> v_85 >> w_85;\n        Edge e = {u_85, v_85, w_85};\n        edges_85.push_back(e);\n    }\n\n    //  S\u1eafp x\u1ebfp c\u00e1c c\u1ea1nh theo th\u1ee9 t\u1ef1 t\u0103ng d\u1ea7n c\u1ee7a tr\u1ecdng s\u1ed1\n    sort(edges_85.begin(), edges_85.end(), [](Edge a, Edge b)\n         { return a.w_85 < b.w_85; });\n\n    int weight_85 = 0;              // Tr\u1ecdng s\u1ed1 nh\u1ecf nh\u1ea5t c\u1ee7a c\u00e2y khung\n    for (int i = 1; i <= N_85; i++) // Kh\u1edfi t\u1ea1o c\u00e1c gi\u00e1 gi\u00e1 tr\u1ecb c\u1ee7a m\u1ea3ng parent v\u00e0 hang\n    {\n        parent_85[i] = i;\n        hang_85[i] = 0;\n    }\n\n    // g\u1ecdi thu\u1eadt to\u00e1n Kuruskal \u0111\u1ec3 t\u00ecm c\u00e2y khung nh\u1ecf nh\u1ea5t\n    for (Edge &e : edges_85)\n    {\n        if (join(e.u_85, e.v_85))\n        {\n            weight_85 += e.w_85;\n        }\n    }\n\n    cout << weight_85; // In ra tr\u1ecdng s\u1ed1 nh\u1ecf nh\u1ea5t c\u1ee7a c\u00e2y khung\n}\n",
        "Bài 2": "// Ph\u00f9ng M\u1ea1nh Ho\u00e0ng 20215385\n// Problem: List order of nodes visited by a DFS\n\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Khai b\u00e1o m\u1ea3ng visited_85 \u0111\u1ec3 \u0111\u00e1nh d\u1ea5u c\u00e1c \u0111\u1ec9nh \u0111\u00e3 \u0111\u01b0\u1ee3c duy\u1ec7t\nbool visited_85[100000] = {false};\n\n// H\u00e0m dfs \u0111\u1ec3 duy\u1ec7t \u0111\u1ed3 th\u1ecb theo chi\u1ec1u s\u00e2u\nvoid dfs(vector<vector<int>> Edges_85, int u_85)\n{\n    // \u0110\u00e1nh d\u1ea5u \u0111\u1ec9nh u_85 \u0111\u00e3 \u0111\u01b0\u1ee3c duy\u1ec7t\n    visited_85[u_85] = true;\n    cout << u_85 << \" \";\n    int size_85 = Edges_85.size();\n    // Duy\u1ec7t qua c\u00e1c \u0111\u1ec9nh k\u1ec1 v\u1edbi u_85\n    for (int v_85 = 1; v_85 <= size_85; v_85++)\n    {\n        // N\u1ebfu c\u00f3 c\u1ea1nh n\u1ed1i t\u1eeb u_85 t\u1edbi v_85 v\u00e0 v_85 ch\u01b0a \u0111\u01b0\u1ee3c duy\u1ec7t th\u00ec ti\u1ebfp t\u1ee5c duy\u1ec7t\n        if (Edges_85[u_85][v_85] == 1 && visited_85[v_85] == false)\n        {\n            dfs(Edges_85, v_85);\n        }\n    }\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n_85, m_85;\n    cin >> n_85 >> m_85;\n\n    // Kh\u1edfi t\u1ea1o ma tr\u1eadn k\u1ec1 Edges_85\n    vector<vector<int>> Edges_85;\n    for (int i = 0; i <= n_85; i++)\n    {\n        vector<int> temp;\n        for (int j = 0; j <= n_85; j++)\n        {\n            temp.push_back(0);\n        }\n        Edges_85.push_back(temp);\n    }\n\n    int u_85, v_85;\n    // \u0110\u1ecdc danh s\u00e1ch c\u1ea1nh v\u00e0 c\u1eadp nh\u1eadt v\u00e0o ma tr\u1eadn k\u1ec1\n    for (int i = 1; i <= m_85; i++)\n    {\n        cin >> u_85 >> v_85;\n        Edges_85[u_85][v_85] = 1;\n        Edges_85[v_85][u_85] = 1;\n    }\n\n    // Duy\u1ec7t qua t\u1ea5t c\u1ea3 c\u00e1c \u0111\u1ec9nh, n\u1ebfu \u0111\u1ec9nh ch\u01b0a \u0111\u01b0\u1ee3c duy\u1ec7t th\u00ec ti\u1ebfn h\u00e0nh duy\u1ec7t DFS t\u1eeb \u0111\u1ec9nh \u0111\u00f3\n    for (int i = 1; i <= n_85; i++)\n    {\n        if (visited_85[i] == false)\n        {\n            dfs(Edges_85, i);\n        }\n    }\n}\n",
        "Bài 3": "// Ph\u00f9ng M\u1ea1nh Ho\u00e0ng 20215385\n// Problem: Sequence of nodes visited by BFS\n\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\n// Khai b\u00e1o m\u1ea3ng visited_85 \u0111\u1ec3 \u0111\u00e1nh d\u1ea5u c\u00e1c \u0111\u1ec9nh \u0111\u00e3 \u0111\u01b0\u1ee3c duy\u1ec7t\nbool visited_85[100000] = {false};\n\n// H\u00e0m bfs \u0111\u1ec3 duy\u1ec7t \u0111\u1ed3 th\u1ecb theo chi\u1ec1u r\u1ed9ng\nvoid bfs(vector<vector<int>> Edges_85, int u_85)\n{\n    // Kh\u1edfi t\u1ea1o h\u00e0ng \u0111\u1ee3i q\n    queue<int> q_85;\n    q_85.push(u_85);\n    visited_85[u_85] = true;\n    while (!q_85.empty())\n    {\n        int v_85 = q_85.front();\n        q_85.pop();\n        cout << v_85 << \" \";\n        int size_85 = Edges_85.size();\n        // Duy\u1ec7t qua c\u00e1c \u0111\u1ec9nh k\u1ec1 v\u1edbi v_85\n        for (int i = 1; i <= size_85; i++)\n        {\n            // N\u1ebfu c\u00f3 c\u1ea1nh n\u1ed1i t\u1eeb v_85 t\u1edbi i v\u00e0 i ch\u01b0a \u0111\u01b0\u1ee3c duy\u1ec7t th\u00ec ti\u1ebfp t\u1ee5c duy\u1ec7t\n            if (Edges_85[v_85][i] == 1 && visited_85[i] == false)\n            {\n                q_85.push(i);\n                visited_85[i] = true;\n            }\n        }\n    }\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n_85, m_85;\n    cin >> n_85 >> m_85;\n\n    // Kh\u1edfi t\u1ea1o ma tr\u1eadn k\u1ec1 Edges_85\n    vector<vector<int>> Edges_85;\n    for (int i = 0; i <= n_85; i++)\n    {\n        vector<int> temp_85;\n        for (int j = 0; j <= n_85; j++)\n        {\n            temp_85.push_back(0);\n        }\n        Edges_85.push_back(temp_85);\n    }\n\n    int u_85, v_85;\n    // \u0110\u1ecdc danh s\u00e1ch c\u1ea1nh v\u00e0 c\u1eadp nh\u1eadt v\u00e0o ma tr\u1eadn k\u1ec1\n    for (int i = 1; i <= m_85; i++)\n    {\n        cin >> u_85 >> v_85;\n        Edges_85[u_85][v_85] = 1;\n        Edges_85[v_85][u_85] = 1;\n    }\n\n    // Duy\u1ec7t qua t\u1ea5t c\u1ea3 c\u00e1c \u0111\u1ec9nh, n\u1ebfu \u0111\u1ec9nh ch\u01b0a \u0111\u01b0\u1ee3c duy\u1ec7t th\u00ec ti\u1ebfn h\u00e0nh duy\u1ec7t BFS t\u1eeb \u0111\u1ec9nh \u0111\u00f3\n    for (int i = 1; i <= n_85; i++)\n    {\n        if (visited_85[i] == false)\n        {\n            bfs(Edges_85, i);\n        }\n    }\n}\n",
        "Bài 4": "// Ph\u00f9ng M\u1ea1nh Ho\u00e0ng 20215385\n// Problem: Hamiton Cycle\n\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\n// H\u00e0m check_hamilton_cycle ki\u1ec3m tra xem \u0111\u1ed3 th\u1ecb c\u00f3 chu tr\u00ecnh Hamilton hay kh\u00f4ng\nbool check_hamilton_cycle(vector<vector<int>> Edges_85, int u_85, int bac_85[])\n{\n    int size_85 = Edges_85.size() - 1;\n    for (int i = 1; i <= size_85; i++)\n    {\n        // N\u1ebfu b\u1eadc c\u1ee7a \u0111\u1ec9nh nh\u1ecf h\u01a1n n\u1eeda s\u1ed1 \u0111\u1ec9nh th\u00ec kh\u00f4ng ph\u1ea3i chu tr\u00ecnh Hamilton\n        if (bac_85[i] < size_85 / 2)\n        {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    ios::sync_with_stdio(false); // T\u1eaft \u0111\u1ed3ng b\u1ed9 gi\u1eefa C v\u00e0 C++ streams\n    cin.tie(0);                  // Kh\u00f4ng li\u00ean k\u1ebft cin v\u1edbi cout\n\n    int T_85;\n    cin >> T_85;\n\n    for (int i = 0; i < T_85; i++)\n    {\n        int n_85, m_85;\n        cin >> n_85 >> m_85;\n\n        // Kh\u1edfi t\u1ea1o ma tr\u1eadn k\u1ec1 Edges_85\n        vector<vector<int>> Edges_85;\n        for (int i = 0; i <= n_85; i++)\n        {\n            vector<int> temp_85;\n            for (int j = 0; j <= n_85; j++)\n            {\n                temp_85.push_back(0);\n            }\n            Edges_85.push_back(temp_85);\n        }\n\n        int u_85, v_85;\n        // Kh\u1edfi t\u1ea1o m\u1ea3ng bac \u0111\u1ec3 l\u01b0u b\u1eadc c\u1ee7a c\u00e1c \u0111\u1ec9nh\n        int bac_85[10000] = {0};\n        // \u0110\u1ecdc danh s\u00e1ch c\u1ea1nh v\u00e0 c\u1eadp nh\u1eadt v\u00e0o ma tr\u1eadn k\u1ec1 v\u00e0 m\u1ea3ng bac\n        for (int i = 1; i <= m_85; i++)\n        {\n            cin >> u_85 >> v_85;\n            Edges_85[u_85][v_85] = 1;\n            Edges_85[v_85][u_85] = 1;\n            bac_85[u_85]++;\n            bac_85[v_85]++;\n        }\n\n        // Ki\u1ec3m tra xem \u0111\u1ed3 th\u1ecb c\u00f3 chu tr\u00ecnh Hamilton hay kh\u00f4ng\n        if (check_hamilton_cycle(Edges_85, u_85, bac_85))\n        {\n            cout << \"1\" << endl;\n        }\n        else\n        {\n            cout << \"0\" << endl;\n        }\n    }\n}\n"
    },
    "Tuần 6": {
        "Bài 1": "// Ph\u00f9ng M\u1ea1nh Ho\u00e0ng 20215385\n// Problem: Max Flow\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF INT_MAX //  Gi\u00e1 tr\u1ecb l\u1edbn nh\u1ea5t cho m\u1ed9t int\n\n// H\u00e0m \u0111\u1ec3 th\u1ef1c hi\u1ec7n ph\u1ea7n BFS c\u1ee7a thu\u1eadt to\u00e1n Edmonds-Karp\nbool bfs(vector<vector<int>> &adj_85, int s_85, int t_85, vector<int> &parent_85)\n{\n    int n_85 = adj_85.size();\n    vector<bool> visited_85(n_85, false);\n    queue<int> q_85;\n    q_85.push(s_85);\n    visited_85[s_85] = true;\n    parent_85[s_85] = -1;\n\n    while (!q_85.empty())\n    {\n        int u_85 = q_85.front();\n        q_85.pop();\n\n        for (int v_85 = 0; v_85 < n_85; v_85++)\n        {\n            if (!visited_85[v_85] && adj_85[u_85][v_85] > 0)\n            {\n                q_85.push(v_85);\n                parent_85[v_85] = u_85;\n                visited_85[v_85] = true;\n            }\n        }\n    }\n\n    return visited_85[t_85];\n}\n\n// H\u00e0m \u0111\u1ec3 th\u1ef1c hi\u1ec7n thu\u1eadt to\u00e1n Edmonds-Karp\nint edmondsKarp(vector<vector<int>> &adj_85, int s_85, int t_85)\n{\n    int n_85 = adj_85.size();\n    vector<int> parent_85(n_85);\n    int max_flow_85 = 0;\n\n    // Trong khi v\u1eabn c\u00f2n \u0111\u01b0\u1eddng \u0111i t\u1eeb s \u0111\u1ebfn t\n    while (bfs(adj_85, s_85, t_85, parent_85))\n    {\n        int path_flow_85 = INF;\n        for (int v_85 = t_85; v_85 != s_85; v_85 = parent_85[v_85])\n        {\n            int u_85 = parent_85[v_85];\n            // T\u00ecm min flow tr\u00ean \u0111\u01b0\u1eddng \u0111i t\u00ecm \u0111\u01b0\u1ee3c\n            path_flow_85 = min(path_flow_85, adj_85[u_85][v_85]);\n        }\n\n        for (int v_85 = t_85; v_85 != s_85; v_85 = parent_85[v_85])\n        {\n            int u_85 = parent_85[v_85];\n            // Tr\u1eeb min flow t\u00ecm \u0111\u01b0\u1ee3c kh\u1ecfi cung thu\u1eadn v\u00e0 c\u1ed9ng v\u00e0o cung ngh\u1ecbch\n            adj_85[u_85][v_85] -= path_flow_85;\n            adj_85[v_85][u_85] += path_flow_85;\n        }\n        // C\u1eadp nh\u1eadt max flow\n        max_flow_85 += path_flow_85;\n    }\n\n    return max_flow_85;\n}\n\nint main()\n{\n    int n_85, m_85;\n    cin >> n_85 >> m_85;                                            // \u0110\u1ecdc s\u1ed1 l\u01b0\u1ee3ng \u0111\u1ec9nh v\u00e0 c\u1ea1nh\n    vector<vector<int>> adj_85(n_85 + 1, vector<int>(n_85 + 1, 0)); // Khai b\u00e1o ma tr\u1eadn k\u1ec1\n\n    int s_85, t_85;\n    cin >> s_85 >> t_85; // \u0110\u1ecdc \u0111\u1ec9nh ngu\u1ed3n v\u00e0 \u0111\u1ec9nh \u0111\u00edch\n\n    for (int i_85 = 0; i_85 < m_85; i_85++)\n    {\n        int u_85, v_85, w_85;\n        cin >> u_85 >> v_85 >> w_85; // \u0110\u1ecdc m\u1ed9t c\u1ea1nh\n        adj_85[u_85][v_85] = w_85;   // Th\u00eam c\u1ea1nh v\u00e0o ma tr\u1eadn k\u1ec1\n    }\n\n    cout << edmondsKarp(adj_85, s_85, t_85); // Ch\u1ea1y thu\u1eadt to\u00e1n Edmonds-Karp v\u00e0 in ra max flow\n}\n",
        "Bài 2": "// Ph\u00f9ng M\u1ea1nh Ho\u00e0ng 20215385\n// Problem: Week 6 - Shortest Path between 2 nodes on a directed graph with non-negative weights\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n#define INF INT_MAX // Gi\u00e1 tr\u1ecb l\u1edbn nh\u1ea5t cho m\u1ed9t int\n\n// H\u00e0m \u0111\u1ec3 th\u1ef1c hi\u1ec7n thu\u1eadt to\u00e1n Dijkstra\nvoid Dijkstra_85(int s_85, vector<int> &dist_85, vector<vector<pair<int, int>>> &adj_85)\n{\n    // Khai b\u00e1o m\u1ed9t h\u00e0ng \u0111\u1ee3i \u01b0u ti\u00ean c\u1ee7a c\u00e1c c\u1eb7p, \u0111\u01b0\u1ee3c s\u1eafp x\u1ebfp theo ph\u1ea7n t\u1eed \u0111\u1ea7u ti\u00ean c\u1ee7a c\u1eb7p\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq_85;\n    pq_85.push({0, s_85}); // \u0110\u1ea9y \u0111\u1ec9nh ngu\u1ed3n v\u00e0o h\u00e0ng \u0111\u1ee3i v\u1edbi kho\u1ea3ng c\u00e1ch 0\n    dist_85[s_85] = 0;     // Kho\u1ea3ng c\u00e1ch t\u1eeb ngu\u1ed3n \u0111\u1ebfn ch\u00ednh n\u00f3 l\u00e0 0\n\n    while (!pq_85.empty())\n    {\n        // L\u1ea5y \u0111\u1ec9nh c\u00f3 kho\u1ea3ng c\u00e1ch nh\u1ecf nh\u1ea5t v\u00e0 lo\u1ea1i b\u1ecf n\u00f3 kh\u1ecfi h\u00e0ng \u0111\u1ee3i\n        pair<int, int> front_85 = pq_85.top();\n        pq_85.pop();\n        int d_85 = front_85.first, u_85 = front_85.second;\n\n        if (d_85 == dist_85[u_85])\n            for (auto &j_85 : adj_85[u_85])\n            {\n                // N\u1ebfu kho\u1ea3ng c\u00e1ch \u0111\u1ebfn \u0111\u1ec9nh k\u1ec1 th\u00f4ng qua \u0111\u1ec9nh hi\u1ec7n t\u1ea1i nh\u1ecf h\u01a1n kho\u1ea3ng c\u00e1ch ng\u1eafn nh\u1ea5t\n                // \u0111\u00e3 bi\u1ebft tr\u01b0\u1edbc \u0111\u00f3\n                // C\u1eadp nh\u1eadt kho\u1ea3ng c\u00e1ch ng\u1eafn nh\u1ea5t v\u00e0 \u0111\u1ea9y \u0111\u1ec9nh k\u1ec1 v\u00e0o h\u00e0ng \u0111\u1ee3i\n                int v_85 = j_85.first, w_85 = j_85.second;\n                if (dist_85[u_85] + w_85 < dist_85[v_85])\n                {\n                    dist_85[v_85] = dist_85[u_85] + w_85;\n                    pq_85.push({dist_85[v_85], v_85});\n                }\n            }\n    }\n}\n\nint main()\n{\n    int n_85, m_85;\n    cin >> n_85 >> m_85;                             // \u0110\u1ecdc s\u1ed1 l\u01b0\u1ee3ng \u0111\u1ec9nh v\u00e0 c\u1ea1nh\n    vector<vector<pair<int, int>>> adj_85(n_85 + 1); // Khai b\u00e1o danh s\u00e1ch k\u1ec1\n\n    // \u0110\u1ecdc c\u00e1c c\u1ea1nh\n    for (int i_85 = 0; i_85 < m_85; i_85++)\n    {\n        int u_85, v_85, w_85;\n        cin >> u_85 >> v_85 >> w_85;          // \u0110\u1ecdc m\u1ed9t c\u1ea1nh\n        adj_85[u_85].push_back({v_85, w_85}); // Th\u00eam c\u1ea1nh v\u00e0o danh s\u00e1ch k\u1ec1\n    }\n\n    int s_85, t_85;\n    cin >> s_85 >> t_85; // \u0110\u1ecdc \u0111\u1ec9nh ngu\u1ed3n v\u00e0 \u0111\u1ec9nh \u0111\u00edch\n\n    vector<int> dist_85(n_85 + 1, INF); // Khai b\u00e1o v\u00e0 kh\u1edfi t\u1ea1o c\u00e1c kho\u1ea3ng c\u00e1ch l\u00e0 v\u00f4 c\u1ef1c\n    Dijkstra_85(s_85, dist_85, adj_85); // Ch\u1ea1y thu\u1eadt to\u00e1n Dijkstra\n\n    // In ra kho\u1ea3ng c\u00e1ch ng\u1eafn nh\u1ea5t t\u1eeb ngu\u1ed3n \u0111\u1ebfn \u0111\u00edch, ho\u1eb7c -1 n\u1ebfu kh\u00f4ng c\u00f3 \u0111\u01b0\u1eddng \u0111i\n    if (dist_85[t_85] != INF)\n        cout << dist_85[t_85];\n    else\n        cout << -1;\n}\n",
        "Bài 3": "// Ph\u00f9ng M\u1ea1nh Ho\u00e0ng 20215385\n// Problem: Week 6 - All pair shortest paths\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF 1e9 // Gi\u00e1 tr\u1ecb l\u1edbn nh\u1ea5t cho m\u1ed9t int\n\n// H\u00e0m \u0111\u1ec3 th\u1ef1c hi\u1ec7n thu\u1eadt to\u00e1n Floyd-Warshall\nvoid Floyd_Warshall_85(vector<vector<int>> &dict_85, int n_85)\n{\n    // V\u00f2ng l\u1eb7p qua t\u1ea5t c\u1ea3 c\u00e1c \u0111\u1ec9nh\n    for (int k_85 = 1; k_85 <= n_85; k_85++)\n    {\n        for (int u_85 = 1; u_85 <= n_85; u_85++)\n        {\n            for (int v_85 = 1; v_85 <= n_85; v_85++)\n            {\n                // N\u1ebfu t\u1ed3n t\u1ea1i \u0111\u01b0\u1eddng \u0111i t\u1eeb u \u0111\u1ebfn k v\u00e0 t\u1eeb k \u0111\u1ebfn v\n                if (dict_85[u_85][k_85] < INF && dict_85[k_85][v_85] < INF)\n                    // C\u1eadp nh\u1eadt kho\u1ea3ng c\u00e1ch ng\u1eafn nh\u1ea5t t\u1eeb u \u0111\u1ebfn v\n                    dict_85[u_85][v_85] = min(dict_85[u_85][v_85], dict_85[u_85][k_85] + dict_85[k_85][v_85]);\n            }\n        }\n    }\n}\n\nint main()\n{\n    int n_85, m_85;\n    cin >> n_85 >> m_85; // \u0110\u1ecdc s\u1ed1 l\u01b0\u1ee3ng \u0111\u1ec9nh v\u00e0 c\u1ea1nh\n\n    // Khai b\u00e1o v\u00e0 kh\u1edfi t\u1ea1o ma tr\u1eadn kho\u1ea3ng c\u00e1ch l\u00e0 v\u00f4 c\u1ef1c\n    vector<vector<int>> dist_85(n_85 + 1, vector<int>(n_85 + 1, INF));\n\n    for (int i_85 = 1; i_85 <= n_85; i_85++)\n    {\n        dist_85[i_85][i_85] = 0; // Kho\u1ea3ng c\u00e1ch t\u1eeb m\u1ed9t \u0111\u1ec9nh \u0111\u1ebfn ch\u00ednh n\u00f3 l\u00e0 0\n    }\n\n    for (int i_85 = 0; i_85 < m_85; i_85++)\n    {\n        int u_85, v_85, w_85;\n        cin >> u_85 >> v_85 >> w_85; // \u0110\u1ecdc m\u1ed9t c\u1ea1nh\n        dist_85[u_85][v_85] = w_85;  // C\u1eadp nh\u1eadt kho\u1ea3ng c\u00e1ch t\u1eeb u \u0111\u1ebfn v\n    }\n\n    Floyd_Warshall_85(dist_85, n_85); // Ch\u1ea1y thu\u1eadt to\u00e1n Floyd-Warshall\n\n    for (int i_85 = 1; i_85 <= n_85; i_85++)\n    {\n        for (int j_85 = 1; j_85 <= n_85; j_85++)\n        {\n            // In ra kho\u1ea3ng c\u00e1ch t\u1eeb i \u0111\u1ebfn j, ho\u1eb7c -1 n\u1ebfu kh\u00f4ng c\u00f3 \u0111\u01b0\u1eddng \u0111i\n            if (dist_85[i_85][j_85] != INF)\n                cout << dist_85[i_85][j_85] << \" \";\n            else\n                cout << \"-1 \";\n        }\n        cout << \"\\n\";\n    }\n}\n"
    },
    "Tuần 7": {
        "Bài 1": "// Ph\u00f9ng M\u1ea1nh Ho\u00e0ng 20215385\n// Problem : Bank Transaction\n\n#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\n// \u0110\u1ecbnh ngh\u0129a c\u1ea5u tr\u00fac Transaction_85 \u0111\u1ec3 l\u01b0u tr\u1eef th\u00f4ng tin v\u1ec1 m\u1ed9t giao d\u1ecbch\ntypedef struct Transaction_85\n{\n    string from_account_85; // ID c\u1ee7a t\u00e0i kho\u1ea3n g\u1eedi\n    string to_account_85;   // ID c\u1ee7a t\u00e0i kho\u1ea3n nh\u1eadn\n    int money_85;           // S\u1ed1 ti\u1ec1n c\u1ee7a giao d\u1ecbch\n    string time_point_85;   // Th\u1eddi \u0111i\u1ec3m giao d\u1ecbch di\u1ec5n ra\n    string atm_85;          // ID c\u1ee7a m\u00e1y ATM n\u01a1i giao d\u1ecbch di\u1ec5n ra\n} Tran_85;\n\n// Kh\u1edfi t\u1ea1o c\u00e1c bi\u1ebfn to\u00e0n c\u1ee5c\nmap<string, vector<string>> adj_85; // Bi\u1ec3u di\u1ec5n \u0111\u1ed3 th\u1ecb giao d\u1ecbch d\u01b0\u1edbi d\u1ea1ng danh s\u00e1ch k\u1ec1\nmap<string, bool> visited_85;       // Bi\u1ec3u di\u1ec5n t\u1eadp h\u1ee3p c\u00e1c \u0111\u1ec9nh \u0111\u00e3 \u0111\u01b0\u1ee3c th\u0103m trong qu\u00e1 tr\u00ecnh DFS\n\n// H\u00e0m DFS \u0111\u1ec3 ki\u1ec3m tra chu tr\u00ecnh\nbool DFS_85(string account_85, string start_85, int depth_85, int k_85)\n{\n    // N\u1ebfu \u0111\u00e3 \u0111i qua \u0111\u1ee7 k b\u01b0\u1edbc v\u00e0 t\u00ecm th\u1ea5y m\u1ed9t c\u1ea1nh tr\u1edf l\u1ea1i \u0111\u1ec9nh b\u1eaft \u0111\u1ea7u\n    if (depth_85 == k_85)\n    {\n        return find(adj_85[account_85].begin(), adj_85[account_85].end(), start_85) != adj_85[account_85].end();\n    }\n    // \u0110\u00e1nh d\u1ea5u \u0111\u1ec9nh hi\u1ec7n t\u1ea1i \u0111\u00e3 \u0111\u01b0\u1ee3c th\u0103m\n    visited_85[account_85] = true;\n    // Duy\u1ec7t qua t\u1ea5t c\u1ea3 c\u00e1c \u0111\u1ec9nh k\u1ec1 v\u1edbi \u0111\u1ec9nh hi\u1ec7n t\u1ea1i\n    for (string next_account_85 : adj_85[account_85])\n    {\n        // N\u1ebfu \u0111\u1ec9nh k\u1ec1 ch\u01b0a \u0111\u01b0\u1ee3c th\u0103m v\u00e0 t\u00ecm th\u1ea5y chu tr\u00ecnh th\u00ec tr\u1ea3 v\u1ec1 true\n        if (!visited_85[next_account_85] && DFS_85(next_account_85, start_85, depth_85 + 1, k_85))\n        {\n            return true;\n        }\n    }\n    // \u0110\u00e1nh d\u1ea5u \u0111\u1ec9nh hi\u1ec7n t\u1ea1i ch\u01b0a \u0111\u01b0\u1ee3c th\u0103m (\u0111\u1ec3 t\u00ecm chu tr\u00ecnh kh\u00e1c)\n    visited_85[account_85] = false;\n    return false;\n}\n\nint main()\n{\n    ios::sync_with_stdio(false); // T\u1eaft \u0111\u1ed3ng b\u1ed9 gi\u1eefa C v\u00e0 C++ streams\n    cin.tie(0);                  // Kh\u00f4ng li\u00ean k\u1ebft cin v\u1edbi cout\n\n    vector<Tran_85> transactions_85; // Danh s\u00e1ch l\u01b0u tr\u1eef th\u00f4ng tin v\u1ec1 c\u00e1c giao d\u1ecbch\n    string s_85;\n    int total_money_transaction_85 = 0; // T\u1ed5ng s\u1ed1 ti\u1ec1n c\u1ee7a t\u1ea5t c\u1ea3 c\u00e1c giao d\u1ecbch\n    map<string, int> from_accounts_85;  // L\u01b0u tr\u1eef t\u1ed5ng s\u1ed1 ti\u1ec1n m\u00e0 m\u1ed7i t\u00e0i kho\u1ea3n \u0111\u00e3 g\u1eedi\n    set<string> accounts_85;            // L\u01b0u tr\u1eef danh s\u00e1ch c\u00e1c t\u00e0i kho\u1ea3n\n    while (true)\n    {\n        cin >> s_85;\n        if (s_85 == \"#\")\n        {\n            break;\n        }\n        Tran_85 t_85;\n        t_85.from_account_85 = s_85;\n        cin >> t_85.to_account_85 >> t_85.money_85 >> t_85.time_point_85 >> t_85.atm_85;\n        transactions_85.push_back(t_85);                         // Th\u00eam giao d\u1ecbch v\u00e0o danh s\u00e1ch\n        from_accounts_85[t_85.from_account_85] += t_85.money_85; // C\u1eadp nh\u1eadt t\u1ed5ng s\u1ed1 ti\u1ec1n m\u00e0 t\u00e0i kho\u1ea3n \u0111\u00e3 g\u1eedi\n    }\n\n    bool check_85 = false;\n    while (true)\n    {\n        cin >> s_85;\n        if (s_85 == \"#\")\n            break;\n        else if (s_85 != \"?total_money_transaction_from\" && check_85 == false)\n        {\n            check_85 = true;\n            for (auto t_85 : transactions_85)\n            {\n                total_money_transaction_85 += t_85.money_85;                // T\u00ednh t\u1ed5ng s\u1ed1 ti\u1ec1n c\u1ee7a t\u1ea5t c\u1ea3 c\u00e1c giao d\u1ecbch\n                accounts_85.insert(t_85.from_account_85);                   // Th\u00eam t\u00e0i kho\u1ea3n g\u1eedi v\u00e0o danh s\u00e1ch t\u00e0i kho\u1ea3n\n                accounts_85.insert(t_85.to_account_85);                     // Th\u00eam t\u00e0i kho\u1ea3n nh\u1eadn v\u00e0o danh s\u00e1ch t\u00e0i kho\u1ea3n\n                adj_85[t_85.from_account_85].push_back(t_85.to_account_85); // Th\u00eam c\u1ea1nh bi\u1ec3u di\u1ec5n giao d\u1ecbch v\u00e0o \u0111\u1ed3 th\u1ecb\n            }\n        }\n\n        if (s_85 == \"?total_money_transaction_from\")\n        {\n            string account_85;\n            cin >> account_85;\n            cout << from_accounts_85[account_85] << endl; // In ra t\u1ed5ng s\u1ed1 ti\u1ec1n m\u00e0 t\u00e0i kho\u1ea3n \u0111\u00e3 g\u1eedi\n        }\n        else if (s_85 == \"?number_transactions\")\n        {\n            cout << transactions_85.size() << endl; // In ra t\u1ed5ng s\u1ed1 giao d\u1ecbch\n        }\n        else if (s_85 == \"?total_money_transaction\")\n        {\n            cout << total_money_transaction_85 << endl; // In ra t\u1ed5ng s\u1ed1 ti\u1ec1n c\u1ee7a t\u1ea5t c\u1ea3 c\u00e1c giao d\u1ecbch\n        }\n        else if (s_85 == \"?list_sorted_accounts\")\n        {\n            for (const string &account_85 : accounts_85)\n            {\n                cout << account_85 << \" \"; // In ra danh s\u00e1ch c\u00e1c t\u00e0i kho\u1ea3n\n            }\n            cout << endl;\n        }\n        else if (s_85 == \"?inspect_cycle\")\n        {\n            string account_85;\n            int k_85;\n            cin >> account_85 >> k_85;\n            visited_85.clear();                                                // X\u00f3a t\u1eadp h\u1ee3p c\u00e1c \u0111\u1ec9nh \u0111\u00e3 \u0111\u01b0\u1ee3c th\u0103m\n            cout << (DFS_85(account_85, account_85, 1, k_85) ? 1 : 0) << endl; // Ki\u1ec3m tra v\u00e0 in ra k\u1ebft qu\u1ea3 ki\u1ec3m tra chu tr\u00ecnh\n        }\n    }\n    return 0;\n}\n",
        "Bài 2": "// Ph\u00f9ng Manh Ho\u00e0ng 20215385\n// Problem: Analyze sales order of an e-commerce company\n\n#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\n// \u0110\u1ecbnh ngh\u0129a c\u1ea5u tr\u00fac giao d\u1ecbch\ntypedef struct Transaction_85\n{\n    string customer_id_85; // ID c\u1ee7a kh\u00e1ch h\u00e0ng\n    string product_id_85;  // ID c\u1ee7a s\u1ea3n ph\u1ea9m\n    int price_85;          // Gi\u00e1 c\u1ee7a s\u1ea3n ph\u1ea9m\n    string shop_id_85;     // ID c\u1ee7a c\u1eeda h\u00e0ng\n    string time_point_85;  // Th\u1eddi \u0111i\u1ec3m giao d\u1ecbch\n} Order_85;\n\n// H\u00e0m so s\u00e1nh \u0111\u1ec3 s\u1eafp x\u1ebfp c\u00e1c giao d\u1ecbch theo th\u1eddi gian\nbool compareByTime_85(const Order_85 &a, const Order_85 &b)\n{\n    return a.time_point_85 < b.time_point_85;\n}\n\nint main()\n{\n    ios::sync_with_stdio(false); // T\u1eaft \u0111\u1ed3ng b\u1ed9 gi\u1eefa C v\u00e0 C++ streams\n    cin.tie(0);                  // Kh\u00f4ng li\u00ean k\u1ebft cin v\u1edbi cout\n\n    vector<Order_85> orders_85; // Danh s\u00e1ch c\u00e1c giao d\u1ecbch\n    string s_85;\n    map<string, int> shop_revenues_85;          // Doanh thu c\u1ee7a m\u1ed7i c\u1eeda h\u00e0ng\n    map<string, int> customer_shop_revenues_85; // Doanh thu t\u1eeb m\u1ed7i kh\u00e1ch h\u00e0ng cho m\u1ed7i c\u1eeda h\u00e0ng\n    map<string, int> accumulated_revenue_85;    // Doanh thu t\u00edch l\u0169y theo th\u1eddi gian\n    while (true)\n    {\n        cin >> s_85;\n        if (s_85 == \"#\")\n        {\n            break;\n        }\n        Order_85 order_85;\n        order_85.customer_id_85 = s_85;\n        cin >> order_85.product_id_85 >> order_85.price_85 >> order_85.shop_id_85 >> order_85.time_point_85;\n        orders_85.push_back(order_85); // Th\u00eam giao d\u1ecbch v\u00e0o danh s\u00e1ch\n    }\n\n    int total_revenue_85 = 0; // T\u1ed5ng doanh thu\n\n    bool check_total_revenue_85 = false;\n    bool check_revenue_of_shop_85 = false;\n    bool check_total_consume_of_customer_shop_85 = false;\n    bool check_total_revenue_in_period_85 = false;\n\n    while (true)\n    {\n        cin >> s_85;\n        if (s_85 == \"#\")\n            break;\n        else if (s_85 == \"?total_number_orders\")\n        {\n            cout << orders_85.size() << endl; // In ra t\u1ed5ng s\u1ed1 giao d\u1ecbch\n        }\n        else if (s_85 == \"?total_revenue\")\n        {\n            if (check_total_revenue_85 == false)\n            {\n                check_total_revenue_85 = true;\n                sort(orders_85.begin(), orders_85.end(), compareByTime_85); // S\u1eafp x\u1ebfp c\u00e1c giao d\u1ecbch theo th\u1eddi gian\n                for (auto &order_85 : orders_85)\n                {\n                    total_revenue_85 += order_85.price_85;                             // T\u00ednh t\u1ed5ng doanh thu\n                    accumulated_revenue_85[order_85.time_point_85] = total_revenue_85; // C\u1eadp nh\u1eadt doanh thu t\u00edch l\u0169y\n                }\n            }\n            cout << total_revenue_85 << endl; // In ra t\u1ed5ng doanh thu\n        }\n        else if (s_85 == \"?revenue_of_shop\")\n        {\n            if (check_revenue_of_shop_85 == false)\n            {\n                check_revenue_of_shop_85 = true;\n                for (auto &order_85 : orders_85)\n                {\n                    shop_revenues_85[order_85.shop_id_85] += order_85.price_85; // T\u00ednh doanh thu c\u1ee7a m\u1ed7i c\u1eeda h\u00e0ng\n                }\n            }\n            string shop_id_85;\n            cin >> shop_id_85;\n            cout << shop_revenues_85[shop_id_85] << endl; // In ra doanh thu c\u1ee7a c\u1eeda h\u00e0ng\n        }\n        else if (s_85 == \"?total_consume_of_customer_shop\")\n        {\n            if (check_total_consume_of_customer_shop_85 == false)\n            {\n                check_total_consume_of_customer_shop_85 = true;\n                for (auto &order_85 : orders_85)\n                {\n                    customer_shop_revenues_85[order_85.customer_id_85 + order_85.shop_id_85] += order_85.price_85; // T\u00ednh doanh thu t\u1eeb m\u1ed7i kh\u00e1ch h\u00e0ng cho m\u1ed7i c\u1eeda h\u00e0ng\n                }\n            }\n            string customer_id_85, shop_id_85;\n            cin >> customer_id_85 >> shop_id_85;\n            cout << customer_shop_revenues_85[customer_id_85 + shop_id_85] << endl; // In ra doanh thu t\u1eeb kh\u00e1ch h\u00e0ng cho c\u1eeda h\u00e0ng\n        }\n        else if (s_85 == \"?total_revenue_in_period\")\n        {\n            if (check_total_revenue_in_period_85 == false)\n            {\n                check_total_revenue_in_period_85 = true;\n                sort(orders_85.begin(), orders_85.end(), compareByTime_85); // S\u1eafp x\u1ebfp c\u00e1c giao d\u1ecbch theo th\u1eddi gian\n                for (auto &order_85 : orders_85)\n                {\n                    total_revenue_85 += order_85.price_85;                             // T\u00ednh t\u1ed5ng doanh thu\n                    accumulated_revenue_85[order_85.time_point_85] = total_revenue_85; // C\u1eadp nh\u1eadt doanh thu t\u00edch l\u0169y\n                }\n            }\n            string from_time_85, to_time_85;\n            cin >> from_time_85 >> to_time_85;\n            auto from_it_85 = accumulated_revenue_85.lower_bound(from_time_85);\n            auto to_it_85 = accumulated_revenue_85.upper_bound(to_time_85);\n            int from_revenue_85 = (from_it_85 == accumulated_revenue_85.begin()) ? 0 : prev(from_it_85)->second;\n            int to_revenue_85 = (to_it_85 == accumulated_revenue_85.begin()) ? 0 : prev(to_it_85)->second;\n            int revenue_85 = to_revenue_85 - from_revenue_85; // T\u00ednh doanh thu trong kho\u1ea3ng th\u1eddi gian\n            cout << revenue_85 << endl;                       // In ra doanh thu trong kho\u1ea3ng th\u1eddi gian\n        }\n    }\n    return 0;\n}\n"
    },
    "Tuần 8": {
        "Bài 1": "// Ph\u00f9ng M\u1ea1nh Ho\u00e0ng 20215385\n// Problem: Analyze Code Submission of a Programming Contest\n\n#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\n// \u0110\u1ecbnh ngh\u0129a c\u1ea5u tr\u00fac Submission_85\nstruct Submission_85\n{\n    string user_id_85;    // ID c\u1ee7a ng\u01b0\u1eddi d\u00f9ng\n    string problem_id_85; // ID c\u1ee7a b\u00e0i to\u00e1n\n    string time_point_85; // Th\u1eddi \u0111i\u1ec3m n\u1ed9p b\u00e0i\n    string status_85;     // Tr\u1ea1ng th\u00e1i c\u1ee7a b\u00e0i n\u1ed9p\n    int point_85;         // \u0110i\u1ec3m s\u1ed1 c\u1ee7a b\u00e0i n\u1ed9p\n};\n\n// H\u00e0m so s\u00e1nh th\u1eddi gian gi\u1eefa m\u1ed9t Submission_85 v\u00e0 m\u1ed9t chu\u1ed7i th\u1eddi gian\nbool compare_time_85(const Submission_85 &sub_85, const string &time_85)\n{\n    return sub_85.time_point_85 < time_85;\n}\n\n// H\u00e0m so s\u00e1nh hai Submission_85 d\u1ef1a tr\u00ean th\u1eddi gian\nbool compare_submissions_85(const Submission_85 &a_85, const Submission_85 &b_85)\n{\n    return a_85.time_point_85 < b_85.time_point_85;\n}\n\nint main()\n{\n    ios::sync_with_stdio(false); // T\u1eaft \u0111\u1ed3ng b\u1ed9 gi\u1eefa C v\u00e0 C++ streams\n    cin.tie(0);                  // Kh\u00f4ng li\u00ean k\u1ebft cin v\u1edbi cout\n\n    // Kh\u1edfi t\u1ea1o vector \u0111\u1ec3 l\u01b0u tr\u1eef c\u00e1c submissions_85\n    vector<Submission_85> submissions_85;\n    // Kh\u1edfi t\u1ea1o map \u0111\u1ec3 l\u01b0u tr\u1eef \u0111i\u1ec3m s\u1ed1 c\u1ee7a ng\u01b0\u1eddi d\u00f9ng\n    map<string, map<string, int>> user_points_85;\n    string s_85;\n\n    // \u0110\u1ecdc d\u1eef li\u1ec7u t\u1eeb \u0111\u1ea7u v\u00e0o\n    while (true)\n    {\n        cin >> s_85;\n        if (s_85 == \"#\")\n            break;\n\n        // Kh\u1edfi t\u1ea1o m\u1ed9t submission m\u1edbi v\u00e0 th\u00eam v\u00e0o danh s\u00e1ch submissions\n        Submission_85 sub_85;\n        sub_85.user_id_85 = s_85;\n        cin >> sub_85.problem_id_85 >> sub_85.time_point_85 >> sub_85.status_85 >> sub_85.point_85;\n        submissions_85.push_back(sub_85);\n    }\n\n    bool check_total_point_of_user_85 = false;\n    bool check_number_submission_period_85 = false;\n\n    // X\u1eed l\u00fd c\u00e1c c\u00e2u truy v\u1ea5n\n    while (true)\n    {\n        cin >> s_85;\n        if (s_85 == \"#\")\n            break;\n\n        if (s_85 == \"?total_point_of_user\" && !check_total_point_of_user_85)\n        {\n            for (auto sub_85 : submissions_85)\n            {\n                if (sub_85.status_85 == \"OK\")\n                {\n                    user_points_85[sub_85.user_id_85][sub_85.problem_id_85] = max(user_points_85[sub_85.user_id_85][sub_85.problem_id_85], sub_85.point_85);\n                }\n            }\n            check_total_point_of_user_85 = true;\n        }\n\n        if (s_85 == \"?number_submission_period\" && !check_number_submission_period_85)\n        {\n            sort(submissions_85.begin(), submissions_85.end(), compare_submissions_85);\n            check_number_submission_period_85 = true;\n        }\n\n        // X\u1eed l\u00fd c\u00e2u truy v\u1ea5n ?total_number_submissions\n        if (s_85 == \"?total_number_submissions\")\n        {\n            cout << submissions_85.size() << endl;\n        }\n\n        // X\u1eed l\u00fd c\u00e2u truy v\u1ea5n ?number_error_submision\n        if (s_85 == \"?number_error_submision\")\n        {\n            int count_85 = 0;\n            for (auto sub_85 : submissions_85)\n            {\n                if (sub_85.status_85 == \"ERR\")\n                    count_85++;\n            }\n            cout << count_85 << endl;\n        }\n        // X\u1eed l\u00fd c\u00e2u truy v\u1ea5n ?number_error_submision_of_user\n        if (s_85 == \"?number_error_submision_of_user\")\n        {\n            string user_id_85;\n            cin >> user_id_85;\n            int count_85 = 0;\n            for (auto sub_85 : submissions_85)\n            {\n                if (sub_85.user_id_85 == user_id_85 && sub_85.status_85 == \"ERR\")\n                    count_85++;\n            }\n            cout << count_85 << endl;\n        }\n\n        // X\u1eed l\u00fd c\u00e2u truy v\u1ea5n ?total_point_of_user\n        if (s_85 == \"?total_point_of_user\")\n        {\n            string user_id_85;\n            cin >> user_id_85;\n            int total_points_85 = 0;\n            for (auto p_85 : user_points_85[user_id_85])\n            {\n                total_points_85 += p_85.second;\n            }\n            cout << total_points_85 << endl;\n        }\n\n        // X\u1eed l\u00fd c\u00e2u truy v\u1ea5n ?number_submission_period\n        if (s_85 == \"?number_submission_period\")\n        {\n            string from_time_85, to_time_85;\n            cin >> from_time_85 >> to_time_85;\n            auto start_85 = lower_bound(submissions_85.begin(), submissions_85.end(), Submission_85{.time_point_85 = from_time_85}, compare_submissions_85);\n            auto end_85 = upper_bound(submissions_85.begin(), submissions_85.end(), Submission_85{.time_point_85 = to_time_85}, compare_submissions_85);\n            cout << distance(start_85, end_85) << endl;\n        }\n    }\n}",
        "Bài 2": "// Ph\u00f9ng M\u1ea1nh Ho\u00e0ng 20215385\n// Problem: Week 8 - Citizen Data Analysis\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass CitizenData_85\n{\nprivate:\n    // \u0110\u1ecbnh ngh\u0129a m\u1ed9t c\u1ea5u tr\u00fac cho Citizen\n    struct Citizen_85\n    {\n        string Code_85, Date_of_birth_85, Father_code_85, Mother_code_85, region_code_85;\n        bool is_alive_85;\n        Citizen_85(string a, string b, string c, string d, bool e, string f) : Code_85(a), Date_of_birth_85(b), Father_code_85(c), Mother_code_85(d), is_alive_85(e), region_code_85(f) {}\n    };\n    vector<Citizen_85> lst_85;             // Danh s\u00e1ch c\u00e1c c\u00f4ng d\u00e2n\n    vector<int> cnt_85;                    // S\u1ed1 l\u01b0\u1ee3ng c\u00f4ng d\u00e2n\n    unordered_map<string, int> id_85;      // B\u1ea3n \u0111\u1ed3 ID c\u00f4ng d\u00e2n\n    int n_85 = 0;                          // S\u1ed1 l\u01b0\u1ee3ng c\u00f4ng d\u00e2n\n    vector<vector<int>> adj_85, parent_85; // Danh s\u00e1ch k\u1ec1 v\u00e0 danh s\u00e1ch cha\n    vector<int> color_85;                  // M\u00e0u c\u1ee7a c\u00e1c n\u00fat\n    int sz_85, d_85, subset_size_85;       // K\u00edch th\u01b0\u1edbc, b\u1eadc, v\u00e0 k\u00edch th\u01b0\u1edbc t\u1eadp con\n    vector<int> dep_85;                    // \u0110\u1ed9 s\u00e2u c\u1ee7a c\u00e1c n\u00fat\n    vector<bool> have_parent_85;           // Ki\u1ec3m tra n\u1ebfu n\u00fat c\u00f3 cha\n    vector<int> f_85;                      // Vector cho quy ho\u1ea1ch \u0111\u1ed9ng\n\n    // H\u00e0m chuy\u1ec3n \u0111\u1ed5i ng\u00e0y th\u00e0nh s\u1ed1 nguy\u00ean\n    int toInt_85(string _date_85)\n    {\n        int res_85 = 0;\n        for (int i = 0; i < _date_85.size(); i++)\n            if (_date_85[i] != '-')\n                res_85 = res_85 * 10 + _date_85[i] - '0';\n        return res_85;\n    }\n    // H\u00e0m t\u00ecm ki\u1ebfm theo chi\u1ec1u s\u00e2u\n    void DFS_85(int u_85, bool c_85)\n    {\n        sz_85++;\n        d_85 += c_85;\n        color_85[u_85] = c_85;\n        for (int v_85 : adj_85[u_85])\n            if (color_85[v_85] == -1)\n                DFS_85(v_85, c_85 ^ 1);\n    }\n    // H\u00e0m quy ho\u1ea1ch \u0111\u1ed9ng\n    int dp_85(int v_85)\n    {\n        if (!have_parent_85[v_85])\n            return 0;\n        if (f_85[v_85])\n            return f_85[v_85];\n        for (int u_85 : parent_85[v_85])\n            f_85[v_85] = max(f_85[v_85], dp_85(u_85) + 1);\n        return f_85[v_85];\n    }\n\npublic:\n    // H\u00e0m th\u00eam m\u1ed9t c\u00f4ng d\u00e2n\n    void add_85(string a, string b, string c, string d, string e, string f)\n    {\n        lst_85.push_back(Citizen_85(a, b, c, d, e == \"Y\", f));\n    }\n    // H\u00e0m chu\u1ea9n h\u00f3a d\u1eef li\u1ec7u\n    void standardize_85()\n    {\n        cnt_85.assign(30010000, 0);\n        adj_85.resize(100001);\n        parent_85.resize(100001);\n        have_parent_85.assign(100001, false);\n        for (auto [_code_85, _date_of_birth_85, _father_code_85, _mother_code_85, _region_code_85, _is_alive_85] : lst_85)\n        {\n            cnt_85[toInt_85(_date_of_birth_85)]++;\n            if (toInt_85(_date_of_birth_85) >= 30010000)\n            {\n                cout << \"ngu\";\n                exit(0);\n            }\n            if (!id_85[_code_85])\n                id_85[_code_85] = ++n_85;\n            if (!id_85[_father_code_85])\n                id_85[_father_code_85] = ++n_85;\n            if (!id_85[_mother_code_85])\n                id_85[_mother_code_85] = ++n_85;\n            if (_father_code_85 != \"0000000\")\n            {\n                parent_85[id_85[_code_85]].push_back(id_85[_father_code_85]);\n                adj_85[id_85[_code_85]].push_back(id_85[_father_code_85]);\n                adj_85[id_85[_father_code_85]].push_back(id_85[_code_85]);\n            }\n            if (_mother_code_85 != \"0000000\")\n            {\n                parent_85[id_85[_code_85]].push_back(id_85[_mother_code_85]);\n                adj_85[id_85[_code_85]].push_back(id_85[_mother_code_85]);\n                adj_85[id_85[_mother_code_85]].push_back(id_85[_code_85]);\n            }\n            have_parent_85[id_85[_code_85]] = (_father_code_85 != \"0000000\" || _mother_code_85 != \"0000000\");\n        }\n\n        for (int i = 1; i < 30010000; i++)\n            cnt_85[i] += cnt_85[i - 1];\n\n        color_85.assign(100001, -1);\n        for (int u_85 = 1; u_85 <= n_85; u_85++)\n            if (color_85[u_85] == -1)\n            {\n                sz_85 = d_85 = 0;\n                DFS_85(u_85, 0);\n                subset_size_85 += max(d_85, sz_85 - d_85);\n            }\n\n        f_85.assign(100001, 0);\n    }\n\n    // H\u00e0m l\u1ea5y s\u1ed1 l\u01b0\u1ee3ng ng\u01b0\u1eddi\n    int number_people_85()\n    {\n        return lst_85.size();\n    }\n    // H\u00e0m l\u1ea5y s\u1ed1 l\u01b0\u1ee3ng ng\u01b0\u1eddi sinh v\u00e0o m\u1ed9t ng\u00e0y c\u1ee5 th\u1ec3\n    int number_of_people_born_at_85(string _date_85)\n    {\n        return cnt_85[toInt_85(_date_85)] - cnt_85[toInt_85(_date_85) - 1];\n    }\n    // H\u00e0m l\u1ea5y t\u1ed5 ti\u00ean s\u1ed1ng l\u00e2u nh\u1ea5t\n    int most_alive_ancestor_85(string _code_85)\n    {\n        return dp_85(id_85[_code_85]);\n    }\n    // H\u00e0m l\u1ea5y s\u1ed1 l\u01b0\u1ee3ng ng\u01b0\u1eddi sinh gi\u1eefa hai ng\u00e0y\n    int number_of_people_born_between_85(string from_date_85, string to_date_85)\n    {\n        return cnt_85[toInt_85(to_date_85)] - cnt_85[toInt_85(from_date_85) - 1];\n    }\n    // H\u00e0m l\u1ea5y s\u1ed1 l\u01b0\u1ee3ng ng\u01b0\u1eddi kh\u00f4ng li\u00ean quan t\u1ed1i \u0111a\n    int max_unrelated_people_85()\n    {\n        return subset_size_85 - 1;\n    }\n};\n\nCitizenData_85 S_85;\n\nsigned main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n\n    string _code_85, _date_of_birth_85, _father_code_85, _mother_code_85, _is_alive_85, _region_code_85;\n    // \u0110\u1ecdc d\u1eef li\u1ec7u t\u1eebng c\u00f4ng d\u00e2n\n    while (cin >> _code_85)\n    {\n        if (_code_85 == \"*\")\n            break;\n        cin >> _date_of_birth_85 >> _father_code_85 >> _mother_code_85 >> _is_alive_85 >> _region_code_85;\n        S_85.add_85(_code_85, _date_of_birth_85, _father_code_85, _mother_code_85, _is_alive_85, _region_code_85);\n    }\n\n    // Chu\u1ea9n h\u00f3a d\u1eef li\u1ec7u\n    S_85.standardize_85();\n\n    string query_85;\n    // X\u1eed l\u00fd c\u00e1c truy v\u1ea5n\n    while (cin >> query_85)\n    {\n        if (query_85 == \"*\")\n            break;\n        if (query_85 == \"NUMBER_PEOPLE\")\n            cout << S_85.number_people_85() << endl;\n        else if (query_85 == \"NUMBER_PEOPLE_BORN_AT\")\n        {\n            string _date_85;\n            cin >> _date_85;\n            cout << S_85.number_of_people_born_at_85(_date_85) << endl;\n        }\n        else if (query_85 == \"MOST_ALIVE_ANCESTOR\")\n        {\n            string _code_85;\n            cin >> _code_85;\n            cout << S_85.most_alive_ancestor_85(_code_85) << endl;\n        }\n        else if (query_85 == \"NUMBER_PEOPLE_BORN_BETWEEN\")\n        {\n            string _from_date_85, _to_date_85;\n            cin >> _from_date_85 >> _to_date_85;\n            cout << S_85.number_of_people_born_between_85(_from_date_85, _to_date_85) << endl;\n        }\n        else if (query_85 == \"MAX_UNRELATED_PEOPLE\")\n            cout << S_85.max_unrelated_people_85() << endl;\n    }\n}\n"
    }
}